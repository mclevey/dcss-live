<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Doing Computational Social ScienceThe Continuous Development Edition - 14&nbsp; Structural similarity and latent social space</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./15-machine-and-statistical-learning.html" rel="next">
<link href="./13-social-networks-and-relational-thinking.html" rel="prev">
<link href="./media/logo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./08-processing-structured-data.html">Exploring Data</a></li><li class="breadcrumb-item"><a href="./14-structural-similarity-and-latent-social-space.html"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Structural similarity and latent social space</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./media/logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Doing Computational Social Science<br><span class="small">The <strong>Continuous Development</strong> Edition</span></a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/UWNETLAB/dcss_supplementary/tree/master/book/" rel="" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">👋 Hello!</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Learning to Do Computational Social Science</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Research Computing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-getting-started.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Getting Started</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-python-101.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Python 101</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-python-102.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Python 102</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Obtaining Data</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-sampling-and-survey-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Sampling and survey data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-web-data-apis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Web data (APIs)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-web-data-scraping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Web data (Scraping)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-audio-image-and-document-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Audio, image, and document data</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Exploring Data</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-processing-structured-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Processing Structured Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-exploratory-data-analysis-and-visualization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Exploratory data analysis and visualization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-association-and-latent-factors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Association and latent factors</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-text-as-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Text as Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-text-similarity-and-latent-semantic-space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Text similarity and latent semantic space</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-social-networks-and-relational-thinking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Networks: Relationships as Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-structural-similarity-and-latent-social-space.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Structural similarity and latent social space</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">Prediction and Inference</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-machine-and-statistical-learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Machine Learning 101</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16-prediction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Prediction</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./17-probability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Probability 101</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18-credibility.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Credibility</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19-causality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Causality</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
 <span class="menu-text">Generative Modeling</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20-linear-regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Bayesian Regression Models with Probabilistic Programming</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./21-multilevel-regression-with-post-stratification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Multilevel regression with post-stratification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./22-generalized-linear-models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Generalized Linear Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./23-causal-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Causal analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./24-latent-structure-networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Latent structure in networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./25-latent-topics-text-lda.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Latent topics in text (LDA)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./26-complex-adaptive-systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Agent-based Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./27-developing-agent-based-models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Diffusion</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">
 <span class="menu-text">Deep Learning Demystified</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./28-artificial-neural-networks-fnn-rnn-cnn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Neural networks 101</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./29-processing-natural-language-data-spacy.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Processing Natural Language Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./30-transformers-self-attention.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">30</span>&nbsp; <span class="chapter-title">Transformers, Self-attention architecture</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./31-latent-topics-text-transformers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">31</span>&nbsp; <span class="chapter-title">Modelling latent topics (Transformers)</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true">
 <span class="menu-text">Professional Responsibilities</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./32-research-ethics-politics-and-practices.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">32</span>&nbsp; <span class="chapter-title">Research Ethics, Politics, and Practices</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./33-next-steps.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">33</span>&nbsp; <span class="chapter-title">Next steps</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">34</span>&nbsp; <span class="chapter-title">Acknowledgements</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./changelog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">35</span>&nbsp; <span class="chapter-title">Changelog</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appendix-centrality-formulas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Centrality Formulas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appendix-courses.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Courses and Workshops</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#network-analysis-with-graph-tool-political-blogs-network" id="toc-network-analysis-with-graph-tool-political-blogs-network" class="nav-link active" data-scroll-target="#network-analysis-with-graph-tool-political-blogs-network"><span class="header-section-number">15</span> Network Analysis with Graph-Tool (Political Blogs Network)</a>
  <ul class="collapse">
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup"><span class="header-section-number">15.1</span> Setup</a></li>
  <li><a href="#property-maps" id="toc-property-maps" class="nav-link" data-scroll-target="#property-maps"><span class="header-section-number">15.2</span> Property Maps</a>
  <ul class="collapse">
  <li><a href="#adjusting-node-colors-exploring-hierarchy" id="toc-adjusting-node-colors-exploring-hierarchy" class="nav-link" data-scroll-target="#adjusting-node-colors-exploring-hierarchy"><span class="header-section-number">15.2.1</span> Adjusting Node Colors &amp; Exploring Hierarchy</a></li>
  <li><a href="#divided-they-blog" id="toc-divided-they-blog" class="nav-link" data-scroll-target="#divided-they-blog"><span class="header-section-number">15.2.2</span> Divided They Blog?</a></li>
  <li><a href="#divided-they-blog-1" id="toc-divided-they-blog-1" class="nav-link" data-scroll-target="#divided-they-blog-1"><span class="header-section-number">15.2.3</span> Divided They Blog?</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#generative-network-analysis-with-bayesian-stochastic-blockmodels" id="toc-generative-network-analysis-with-bayesian-stochastic-blockmodels" class="nav-link" data-scroll-target="#generative-network-analysis-with-bayesian-stochastic-blockmodels"><span class="header-section-number">16</span> Generative Network Analysis with Bayesian Stochastic Blockmodels</a>
  <ul class="collapse">
  <li><a href="#learning-outcomes" id="toc-learning-outcomes" class="nav-link" data-scroll-target="#learning-outcomes"><span class="header-section-number">16.1</span> LEARNING OUTCOMES</a></li>
  <li><a href="#learning-materials" id="toc-learning-materials" class="nav-link" data-scroll-target="#learning-materials"><span class="header-section-number">16.2</span> LEARNING MATERIALS</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">16.3</span> INTRODUCTION</a>
  <ul class="collapse">
  <li><a href="#latent-network-structure-connected-communities-and-structural-positions" id="toc-latent-network-structure-connected-communities-and-structural-positions" class="nav-link" data-scroll-target="#latent-network-structure-connected-communities-and-structural-positions"><span class="header-section-number">16.3.1</span> Latent Network Structure: Connected Communities and Structural Positions</a></li>
  <li><a href="#bayesian-hierarchical-stochastic-blockmodels" id="toc-bayesian-hierarchical-stochastic-blockmodels" class="nav-link" data-scroll-target="#bayesian-hierarchical-stochastic-blockmodels"><span class="header-section-number">16.3.2</span> Bayesian Hierarchical Stochastic Blockmodels</a></li>
  </ul></li>
  <li><a href="#blockmodelling-with-graph-tool" id="toc-blockmodelling-with-graph-tool" class="nav-link" data-scroll-target="#blockmodelling-with-graph-tool"><span class="header-section-number">16.4</span> BLOCKMODELLING WITH GRAPH-TOOL</a>
  <ul class="collapse">
  <li><a href="#installing-graph-tool" id="toc-installing-graph-tool" class="nav-link" data-scroll-target="#installing-graph-tool"><span class="header-section-number">16.4.1</span> Installing graph-tool</a></li>
  <li><a href="#understanding-property-maps" id="toc-understanding-property-maps" class="nav-link" data-scroll-target="#understanding-property-maps"><span class="header-section-number">16.4.2</span> Understanding Property Maps</a></li>
  <li><a href="#imports" id="toc-imports" class="nav-link" data-scroll-target="#imports"><span class="header-section-number">16.4.3</span> Imports</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data"><span class="header-section-number">16.4.4</span> Data</a></li>
  <li><a href="#developing-stochastic-blockmodels" id="toc-developing-stochastic-blockmodels" class="nav-link" data-scroll-target="#developing-stochastic-blockmodels"><span class="header-section-number">16.4.5</span> Developing Stochastic Blockmodels</a></li>
  <li><a href="#model-selection-and-optimization" id="toc-model-selection-and-optimization" class="nav-link" data-scroll-target="#model-selection-and-optimization"><span class="header-section-number">16.4.6</span> Model Selection and Optimization</a></li>
  <li><a href="#more-mcmc" id="toc-more-mcmc" class="nav-link" data-scroll-target="#more-mcmc"><span class="header-section-number">16.4.7</span> More MCMC</a></li>
  <li><a href="#visualizing-block-connections-as-a-radial-tree" id="toc-visualizing-block-connections-as-a-radial-tree" class="nav-link" data-scroll-target="#visualizing-block-connections-as-a-radial-tree"><span class="header-section-number">16.4.8</span> Visualizing Block Connections as a Radial Tree</a></li>
  <li><a href="#topsbm-a-unified-bayesian-approach-to-latent-variable-modelling-for-text-and-networks" id="toc-topsbm-a-unified-bayesian-approach-to-latent-variable-modelling-for-text-and-networks" class="nav-link" data-scroll-target="#topsbm-a-unified-bayesian-approach-to-latent-variable-modelling-for-text-and-networks"><span class="header-section-number">16.4.9</span> TopSBM: A Unified Bayesian Approach to Latent Variable Modelling for Text and Networks</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">16.5</span> CONCLUSION</a>
  <ul class="collapse">
  <li><a href="#key-points" id="toc-key-points" class="nav-link" data-scroll-target="#key-points"><span class="header-section-number">16.5.1</span> Key Points</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#connection-and-clustering-in-social-networks" id="toc-connection-and-clustering-in-social-networks" class="nav-link" data-scroll-target="#connection-and-clustering-in-social-networks"><span class="header-section-number">17</span> Connection and Clustering in Social Networks</a>
  <ul class="collapse">
  <li><a href="#learning-objectives" id="toc-learning-objectives" class="nav-link" data-scroll-target="#learning-objectives"><span class="header-section-number">17.1</span> LEARNING OBJECTIVES</a></li>
  <li><a href="#learning-materials-1" id="toc-learning-materials-1" class="nav-link" data-scroll-target="#learning-materials-1"><span class="header-section-number">17.2</span> LEARNING MATERIALS</a></li>
  <li><a href="#introduction-1" id="toc-introduction-1" class="nav-link" data-scroll-target="#introduction-1"><span class="header-section-number">17.3</span> INTRODUCTION</a>
  <ul class="collapse">
  <li><a href="#imports-1" id="toc-imports-1" class="nav-link" data-scroll-target="#imports-1"><span class="header-section-number">17.3.1</span> Imports</a></li>
  <li><a href="#data-1" id="toc-data-1" class="nav-link" data-scroll-target="#data-1"><span class="header-section-number">17.3.2</span> Data</a></li>
  </ul></li>
  <li><a href="#micro-level-network-structure-and-processes" id="toc-micro-level-network-structure-and-processes" class="nav-link" data-scroll-target="#micro-level-network-structure-and-processes"><span class="header-section-number">17.4</span> MICRO-LEVEL NETWORK STRUCTURE AND PROCESSES</a>
  <ul class="collapse">
  <li><a href="#dyads-and-reciprocity" id="toc-dyads-and-reciprocity" class="nav-link" data-scroll-target="#dyads-and-reciprocity"><span class="header-section-number">17.4.1</span> Dyads and Reciprocity</a></li>
  <li><a href="#triads-and-triadic-closure" id="toc-triads-and-triadic-closure" class="nav-link" data-scroll-target="#triads-and-triadic-closure"><span class="header-section-number">17.4.2</span> Triads and Triadic Closure</a></li>
  <li><a href="#man-for-triads" id="toc-man-for-triads" class="nav-link" data-scroll-target="#man-for-triads"><span class="header-section-number">17.4.3</span> MAN for Triads</a></li>
  </ul></li>
  <li><a href="#detecting-cohesive-subgroups-and-assortative-structure" id="toc-detecting-cohesive-subgroups-and-assortative-structure" class="nav-link" data-scroll-target="#detecting-cohesive-subgroups-and-assortative-structure"><span class="header-section-number">17.5</span> DETECTING COHESIVE SUBGROUPS AND ASSORTATIVE STRUCTURE</a>
  <ul class="collapse">
  <li><a href="#cliques-and-k-clique-communities" id="toc-cliques-and-k-clique-communities" class="nav-link" data-scroll-target="#cliques-and-k-clique-communities"><span class="header-section-number">17.5.1</span> Cliques and <span class="math inline">\(k\)</span>-Clique Communities</a></li>
  <li><a href="#community-detection-using-louvain-and-leiden" id="toc-community-detection-using-louvain-and-leiden" class="nav-link" data-scroll-target="#community-detection-using-louvain-and-leiden"><span class="header-section-number">17.5.2</span> Community Detection using Louvain and Leiden</a></li>
  <li><a href="#components-and-k-cores" id="toc-components-and-k-cores" class="nav-link" data-scroll-target="#components-and-k-cores"><span class="header-section-number">17.5.3</span> Components and <span class="math inline">\(k\)</span>-cores</a></li>
  </ul></li>
  <li><a href="#conclusion-1" id="toc-conclusion-1" class="nav-link" data-scroll-target="#conclusion-1"><span class="header-section-number">17.6</span> CONCLUSION</a>
  <ul class="collapse">
  <li><a href="#key-points-1" id="toc-key-points-1" class="nav-link" data-scroll-target="#key-points-1"><span class="header-section-number">17.6.1</span> Key Points</a></li>
  </ul></li>
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section"><span class="header-section-number">17.7</span> </a>
  <ul class="collapse">
  <li><a href="#pitfalls-and-problems-with-heuristic-network-analysis" id="toc-pitfalls-and-problems-with-heuristic-network-analysis" class="nav-link" data-scroll-target="#pitfalls-and-problems-with-heuristic-network-analysis"><span class="header-section-number">17.7.1</span> pitfalls and problems <br>with <span class="kn-pink">heuristic</span> network analysis</a></li>
  </ul></li>
  <li><a href="#section-1" id="toc-section-1" class="nav-link" data-scroll-target="#section-1"><span class="header-section-number">17.8</span> </a></li>
  <li><a href="#section-2" id="toc-section-2" class="nav-link" data-scroll-target="#section-2"><span class="header-section-number">17.9</span> </a></li>
  <li><a href="#section-3" id="toc-section-3" class="nav-link" data-scroll-target="#section-3"><span class="header-section-number">17.10</span> </a></li>
  <li><a href="#section-4" id="toc-section-4" class="nav-link" data-scroll-target="#section-4"><span class="header-section-number">17.11</span> </a></li>
  <li><a href="#section-5" id="toc-section-5" class="nav-link" data-scroll-target="#section-5"><span class="header-section-number">17.12</span> </a>
  <ul class="collapse">
  <li><a href="#heuristic-community-detection-via-modularity-maximization" id="toc-heuristic-community-detection-via-modularity-maximization" class="nav-link" data-scroll-target="#heuristic-community-detection-via-modularity-maximization"><span class="header-section-number">17.12.1</span> Heuristic Community Detection<br>via Modularity Maximization</a></li>
  </ul></li>
  <li><a href="#section-6" id="toc-section-6" class="nav-link" data-scroll-target="#section-6"><span class="header-section-number">17.13</span> </a></li>
  <li><a href="#section-7" id="toc-section-7" class="nav-link" data-scroll-target="#section-7"><span class="header-section-number">17.14</span> </a>
  <ul class="collapse">
  <li><a href="#what-is-q" id="toc-what-is-q" class="nav-link" data-scroll-target="#what-is-q"><span class="header-section-number">17.14.1</span> What is <span class="math inline">\(Q\)</span>?</a></li>
  </ul></li>
  <li><a href="#section-8" id="toc-section-8" class="nav-link" data-scroll-target="#section-8"><span class="header-section-number">17.15</span> </a>
  <ul class="collapse">
  <li><a href="#what-is-q-1" id="toc-what-is-q-1" class="nav-link" data-scroll-target="#what-is-q-1"><span class="header-section-number">17.15.1</span> What is <span class="math inline">\(Q\)</span>?</a></li>
  </ul></li>
  <li><a href="#section-9" id="toc-section-9" class="nav-link" data-scroll-target="#section-9"><span class="header-section-number">17.16</span> </a>
  <ul class="collapse">
  <li><a href="#what-is-q-2" id="toc-what-is-q-2" class="nav-link" data-scroll-target="#what-is-q-2"><span class="header-section-number">17.16.1</span> What is <span class="math inline">\(Q\)</span>?</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/UWNETLAB/dcss_supplementary/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Structural similarity and latent social space</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Planned Revisions
</div>
</div>
<div class="callout-body-container callout-body">
<p>This chapter is being revised in fall 2024. The revised version will serve as a general networks EDA chapter, which often involves plotting networks, performing some sort of community detection to reduce a complex network, and some kind of centrality analysis. In the worst case, these are done naively and / or mindlessly. Since centrality analysis was introduced in the previous chapter, this chapter will focus on visualization and community detection.</p>
<p>It will use the political blogs example (graph-tool) to introduce visualization and force-directed layouts, as well as crique mindless application of modularity-maximization approaches to community detection. It will introduce assortative and positional structure and contrast the two approaches to partitioning networks. It will apply a first SBM but won’t get into posterior inference (yet). It will end with the idea of latent social space and feature a short section on latent position models (which dovetail nicely with the other chapters in this section that use dimensionality reduction methods).</p>
<p>For now, this chapter contains several chapters back to back. They will be consolidated shortly (as in over the next few days).</p>
</div>
</div>
<!-- 
Start with visualization and divided we blog example. Then: 

In the last chapter we took a kind of "networked individuals" approach, which is intuitive. We also stuck with networks at the level they were observed. But often we want to generalize beyond our specific observations, much like in text and structured data. There have been many proposals for how to do this. With assortative structure, we often think of position in terms of centrality, since it assumes a flow- or walk-like perspective. And we use community detection to do this. Louvain and Leiden suck and we want to avoid them if we can. An alternative is to use a Planted Partition Model (PPM). 

Or we can think in terms of latent positions and blocks, and to do that we turn to blockmodelling. Here we fit a first non-PPM SBM, but don't get into inference. 
 -->
<section id="network-analysis-with-graph-tool-political-blogs-network" class="level1" data-number="15">
<h1 data-number="15"><span class="header-section-number">15</span> Network Analysis with Graph-Tool (Political Blogs Network)</h1>
<section id="setup" class="level2" data-number="15.1">
<h2 data-number="15.1" class="anchored" data-anchor-id="setup"><span class="header-section-number">15.1</span> Setup</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> graph_tool.<span class="bu">all</span> <span class="im">as</span> gt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> icsspy.networks <span class="im">import</span> rotate_positions</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Using graph-tool version </span><span class="sc">{</span>gt<span class="sc">.</span>__version__<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Load the data.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> gt.collection.data[<span class="st">"polblogs"</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(g.gp.readme)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="property-maps" class="level2" data-number="15.2">
<h2 data-number="15.2" class="anchored" data-anchor-id="property-maps"><span class="header-section-number">15.2</span> Property Maps</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(g.vp.value)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can look up the political class for any given node by passing its integer ID. For example, vertex 30:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>g.vp.value[<span class="dv">30</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To view all classifications, we can iterate over the vertices and print each vertex ID followed by its class label:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> g.vertices():</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(v, g.vp.value[v])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>political_colors <span class="op">=</span> {<span class="dv">0</span>: <span class="st">"#2F357E"</span>, <span class="dv">1</span>: <span class="st">"#D72F32"</span>}  <span class="co"># color map</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>vertex_political_colors <span class="op">=</span> g.new_vertex_property(<span class="st">"string"</span>)  <span class="co"># new vertex property</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># assign colors to each vertex based on the political classification</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> g.vertices():</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    vertex_political_colors[v] <span class="op">=</span> political_colors[g.vp.value[v]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As a first step, let’s recreate the political blogs figures we’ve seen so far (including those based on the nested SBM). We’ll assign node positions using the <strong>stable force directed placement</strong> function, <code>sfdp_layout()</code>. This will more-or-less recreate the force directed layout from the original.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> gt.sfdp_layout(g)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>gt.graph_draw(</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    g, pos,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    vertex_fill_color<span class="op">=</span>vertex_political_colors,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">1200</span>),</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], <span class="co"># white background (transparent by default)</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    inline<span class="op">=</span><span class="va">True</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s just focus on the giant component for a cleaner visualization. We’ll also rotate the graph’s position to match the figures more closely.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>giant <span class="op">=</span> gt.extract_largest_component(g, directed<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> gt.sfdp_layout(giant)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> rotate_positions(pos, a<span class="op">=</span><span class="dv">90</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>gt.graph_draw(</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    giant, pos,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    vertex_fill_color<span class="op">=</span>vertex_political_colors,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">1200</span>),</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    inline<span class="op">=</span><span class="va">True</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next, we fit an SBM and color the nodes based on their estimated block membership.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>blockstate <span class="op">=</span> gt.minimize_nested_blockmodel_dl(giant)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>blockstate_level_0 <span class="op">=</span> blockstate.levels[<span class="dv">0</span>]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>blockstate_level_0</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can use the <code>.draw()</code> method for blockstate objects.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>blockstate_level_0.draw(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    pos<span class="op">=</span>pos,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">1200</span>),</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Another figure more-or-less recreated! Two more to go.</p>
<p>Let’s modify the force directed layout to add attractive forces for block membership.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>pos_refined <span class="op">=</span> gt.sfdp_layout(g, groups<span class="op">=</span>blockstate_level_0.b, gamma<span class="op">=</span><span class="fl">.04</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>pos_refined <span class="op">=</span> rotate_positions(pos_refined, <span class="dv">125</span>) <span class="co"># make it horizontal</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Then we can visualize the blockstate again.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>blockstate_level_0.draw(</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    pos<span class="op">=</span>pos_refined,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    edge_gradient<span class="op">=</span>[],</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"#33333322"</span>,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">1200</span>),</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As a refinement step <strong>based on model criticism</strong>, we’ll adjust the force-directed layout by adding an attractive force between nodes in the same block. This is done by passing the following arguments to <code>sfdp_layout()</code>:</p>
<ul>
<li><code>groups</code>: A vertex property map that assigns nodes to specific groups, in this case, block assignments at the lowest level of the nested SBM (<code>blockstate_level_0.b</code>). This adds additional attractive forces for block membership in the layout.</li>
<li><code>gamma</code>: Controls the strength of the attractive force for nodes in the same block. A small value corresponds to a weak force and more spread out clusters, while a larger value results in more compact clusters.</li>
</ul>
<p>We’ll pass <code>blockstate_level_0.b</code> (block assignments) to <code>sfdp_layout()</code>. The <code>.b</code> attribute provides access to the block assignments.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>pos_refined <span class="op">=</span> rotate_positions(pos_refined, <span class="dv">45</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>😌 Look at that!</p>
<section id="adjusting-node-colors-exploring-hierarchy" class="level3" data-number="15.2.1">
<h3 data-number="15.2.1" class="anchored" data-anchor-id="adjusting-node-colors-exploring-hierarchy"><span class="header-section-number">15.2.1</span> Adjusting Node Colors &amp; Exploring Hierarchy</h3>
<p>For the final adjustment, let’s assign node colors based on political classification rather than block membership and use a layout that is designed to emphasize the hierarchical structure of the network. Even though we are dropping back down to two colors, the block structure will still be evident from the layout and we should be able to how well the binary classification lines up with the hierarchical blockmodel.</p>
</section>
<section id="divided-they-blog" class="level3" data-number="15.2.2">
<h3 data-number="15.2.2" class="anchored" data-anchor-id="divided-they-blog"><span class="header-section-number">15.2.2</span> Divided They Blog?</h3>
<p>What do you think?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>blockstate.draw(</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    vertex_fill_color<span class="op">=</span>vertex_political_colors,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">1200</span>),</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    inline<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This visualization reveals the hierarchical structure more clearly. It’s a bit tough to see right now, but the blue square node right in the middle of the network represents the entire graph merged into one group at the highest level of the block hierarchy. As you move outward from the center, the graph splits into smaller and smaller blocks, which correspond to different political blogs at the lowest level of the block hierarchy.</p>
<p>You may notice that the nested SBM reveals a more complex structure than a simple left-right division. The hierarchy shows internal differentiation within each political cluster, revealing sub-communities that were not as apparent in the force-directed layout. However, we can see a clear split into two groups at the highest-level below the full graph that does align with the binary classifications.</p>
</section>
<section id="divided-they-blog-1" class="level3" data-number="15.2.3">
<h3 data-number="15.2.3" class="anchored" data-anchor-id="divided-they-blog-1"><span class="header-section-number">15.2.3</span> Divided They Blog?</h3>
<p>Let’s tweak the appearance of the block-level graph to make it easier to see and more visually appealing. We will modify the properties of the hierarchical block nodes and edges using <code>hvprops</code> (hierarchical vertex properties) and <code>heprops</code> (hierarchical edge properties).</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>hvprops <span class="op">=</span> {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"fill_color"</span>: <span class="st">"white"</span>,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"size"</span>: <span class="dv">30</span>,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>heprops <span class="op">=</span> {</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"color"</span>: <span class="st">"white"</span>,</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"pen_width"</span>: <span class="dv">2</span>,</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>blockstate.draw(</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    vertex_fill_color<span class="op">=</span>vertex_political_colors,</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    hvprops<span class="op">=</span>hvprops,</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    heprops<span class="op">=</span>heprops,</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">1200</span>),</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    inline<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With that, we’ve successfully recreated the series of political blog network figures from the lecture using <code>graph-tool</code>. We learned how to run <code>graph-tool</code> code in a conda environment, extracted the giant component, fit our first nested Stochastic Blockmodel (NSBM), and created a series of visualizions of the network and it’s hierarchical block structure. We also learned how to adjust force_directed layouts to add additional attractors for group memberships based on simple model criticism, and how to modify and refine the visual properties of networks at different levels of the block hierarchy.</p>
<p>In the next part of the tutorial, we’ll explore the Enron email networks, applying similar techniques and deepening our understanding of community detection in large networks. We’ll fit different kinds of models to different kinds of network representations and then rank the models based on their description lengths. As a bonus, we will compare these to results from modularity-maximization approaches (which you should not use).</p>
<p>We just</p>
<ul>
<li>recreated the figures</li>
<li>fit and visualized our first Nested Stochastic Blockmodel</li>
<li>learned how to modify the observed and hierachical networks in <code>graph-tool</code> visualizations</li>
</ul>
</section>
</section>
</section>
<section id="generative-network-analysis-with-bayesian-stochastic-blockmodels" class="level1" data-number="16">
<h1 data-number="16"><span class="header-section-number">16</span> Generative Network Analysis with Bayesian Stochastic Blockmodels</h1>
<section id="learning-outcomes" class="level2" data-number="16.1">
<h2 data-number="16.1" class="anchored" data-anchor-id="learning-outcomes"><span class="header-section-number">16.1</span> LEARNING OUTCOMES</h2>
<ul>
<li>Explain how stochastic equivalence builds upon, yet is distinct from, structural equivalence</li>
<li>Describe the Bayesian logic of Stochastic BlockModels (SBMs) and how they aggregate nodes into stochastically equivalent blocks</li>
<li>Use <code>graph-tool</code> to produce posterior distributions of nodes in hierarchically nested blocks</li>
<li>Understand how TopSBM unifies SBMs and LDA models</li>
</ul>
</section>
<section id="learning-materials" class="level2" data-number="16.2">
<h2 data-number="16.2" class="anchored" data-anchor-id="learning-materials"><span class="header-section-number">16.2</span> LEARNING MATERIALS</h2>
<p>You can find the online learning materials for this chapter in <code>doing_computational_social_science/Chapter_31</code>. <code>cd</code> into the directory and launch your Jupyter Server.</p>
</section>
<section id="introduction" class="level2" data-number="16.3">
<h2 data-number="16.3" class="anchored" data-anchor-id="introduction"><span class="header-section-number">16.3</span> INTRODUCTION</h2>
<p>In the previous chapter, we used Bayesian generative models to identify latent topic structure in text data. In this chapter, we use the same underlying Bayesian logic to tackle some difficult problems in network analysis. Just as LDA addresses topic modelling as a latent variable problem using generative models, the models we introduce here – stochastic block models (SBMs) – approach network structure a similar way. Whereas LDA assumes that documents contain a mixture of latent topics that are made up of words, SBMs assume that networks have latent modular structure, and the goal is to figure out how to partition a network according to these low-level building blocks.</p>
<p>I’ll start by briefly introducing some new theoretical ideas about “equivalence” and structural positions in networks. Then, I’ll emphasize the theoretical and the generative logic of SBMs and their hierarchical Bayesian design. Then I’ll discuss the role of Bayesian inference in SBMs, following a similar explanatory process as in the previous chapter.</p>
<p>In the second half of the chapter, we’ll focus on three related things. First, I’ll introduce the Python package graph-tool. Second, we will fit a series of SBMs to an email communication network of Enron employees involved in the legal proceedings of the Enron scandal. Third and finally, we will return to the comparison of LDA and SBM. I’ll emphasize the shared conceptual logic of the problems of topic modelling and community detection. Then I’ll introduce TopSBMs as a shared modelling framework for both tasks. This combination marks the end of our journey through Bayesian generative modelling and probabilistic programming.</p>
<section id="latent-network-structure-connected-communities-and-structural-positions" class="level3" data-number="16.3.1">
<h3 data-number="16.3.1" class="anchored" data-anchor-id="latent-network-structure-connected-communities-and-structural-positions"><span class="header-section-number">16.3.1</span> Latent Network Structure: Connected Communities and Structural Positions</h3>
<p>Generally speaking, network researchers think about the structure of social networks in one of two ways, each of which posits different social mechanisms to produce an outcome of interest (such as whether someone adopts a belief or behaviour), or give rise to different kinds of patterns in network structure. Both perspectives subsume a wide variety of specific methods, measures, and models.</p>
<p>The first of these two perspectives focuses mainly on issues related to <strong>connection, cohesion, and network flow</strong>. We work within this <strong>general perspective</strong> anytime we are thinking through the processes by which ties and cohesive subgroups form and dissolve, or when concerned with the role of networks in facilitating or mitigating the <em>spread</em> of a contagion or the creation of opportunities from one’s direct ties or the structure of ties in their neighbourhood. Everything we have discussed in relation to networks to this point in the book has assumed this general perspective. Because of the role of direct connection and walk-structure, research that adopts this perspective measures and models <em>specific</em> relationships between <em>specific</em> nodes.</p>
<p>By contrast, <strong>positional approaches</strong> are premised on the notion that we can reduce the complexity of networks that represent specific relationships between specific nodes to a smaller set of connections between <strong>blocks</strong> (i.e., groups) of nodes that are judged to be “equivalent” in some meaningful way. In other words, each “block” in a network consists of a group of structurally interchangeable nodes, each of which share a common <strong>structural position</strong> in the network. The research goals here focus on understanding the <em>general</em> relationships between <em>general structural positions</em> rather than understanding the specific connections between specific people.</p>
<p>Why would we care to do this in the first place? It depends on whom you ask, but you a common motivation for working with this positional approach is <strong>generalization</strong>: we want to abstract away the concrete details of specific connections between specific people to focus on understanding <em>the big picture, in general</em>. As we will soon see, this way of thinking lends itself well to probabilistic models of network structure, and is more robust to problems that arise from the imprecise and imperfect observation and measurement of relational data.</p>
<p>Let’s imagine a simple scenario. Imagine two professors, each principal investigators of research labs at a university but in completely different departments and with no overlap in their research agendas or lab members. Let’s also assume that both labs have a fairly hierarchical organizational structure, as is historically typical of many sciences. In both cases, the professors have a group of students and lab technicians who report directly to them. Regardless of how we measure relevant network ties (e.g., communication, collaboration, advice-giving), the community detection we methods we discussed in Chapter 15 would place both professors into different communities. From a connection, community, and flow perspective, these two professors and their labs are completely distinct, with the only relationships between them being indirect connections along the walk structure of the network. By contrast, the models we’re going to discuss in the rest of this chapter would identify the two professors as being <strong>equivalent</strong> despite the fact that they are not connected to one another and they have no connections in common. This is because the focus is on <em>general</em> patterns of <em>aggregate</em> relations between <em>categories</em> of nodes <span class="citation" data-cites="jscott cprell">(<a href="references.html#ref-jscott" role="doc-biblioref">Scott 2013</a>; <a href="references.html#ref-cprell" role="doc-biblioref">Prell 2013</a>)</span>.</p>
<p>Nodes that occupy the same structural positions in a network tend to have behavioural similarities even when they are not connected to one another. Structurally equivalent nodes may behave in similar ways because they are conforming, to varying degrees, to the expectations associated with their position and social roles. Professors do what professors do, grad students do what grad students do, undergrad students do what undergrad students do, and so on. Another mechanistic explanation is that equivalent nodes have to negotiate similar types of problems, situations, and institutional environments, and they exhibit behavioural similarities due to these common experiences and contexts rather than the influence of their direct social ties (bringing us back to that idea of <em>shared institutional environments</em> and the connection to hierarchical models first introduced in Chapter 29).</p>
<p>Finally, people who occupy the same structural positions in networks might look to mirror the behaviours of other people who share their structural positions. For example, if they are uncertain about how to behave, or what is needed for success, they may model their behaviour on someone who is in the same position and seems to be thriving (similarly, they may observe behaviours and outcomes they want to <em>avoid</em>). Returning to our hypothetical example: it doesn’t stretch credibility to claim that a professor is more likely to make decisions about running their research lab based on observations of how similar professors run their labs than the interpersonal influence of their friends and family (who are not professors running research labs).</p>
<p>The first thing we need to do in any positional analysis is specify an exactly what we mean by “equivalence.” We need an operational definition.</p>
<section id="equivalence" class="level4" data-number="16.3.1.1">
<h4 data-number="16.3.1.1" class="anchored" data-anchor-id="equivalence"><span class="header-section-number">16.3.1.1</span> Equivalence?</h4>
<p><span class="citation" data-cites="lorrain1971structural">Lorrain and White (<a href="references.html#ref-lorrain1971structural" role="doc-biblioref">1971</a>)</span> theorized that nodes in a network could be considered <strong>structurally equivalent</strong> if they connected to the rest of a network in <em>identical</em> ways. In this definition, equivalent nodes are literally substitutable for one another, which was the initial inspiration behind the move to aggregate nodes into abstract blocks that reveal an underlying structure of generic positions and social roles.</p>
<p>It is exceedingly rare to find nodes that meet this strict definition of equivalence when analyzing real social networks. As a result, we typically use some measure of <em>approximate equivalence</em> instead. Since Lorraine and White’s classic article, researchers have proposed many different ways of conceptualizing equivalence executing positional analyses, one of the most influential of which was White and Reitz’s <span class="citation" data-cites="white1983graph">(<a href="references.html#ref-white1983graph" role="doc-biblioref">1983</a>)</span> <strong>regular equivalence</strong>. To be “regularly equivalent,” nodes must have similar connection profiles to other regular equivalence classes, rather than the identical connection profile of structural equivalence.</p>
<p>Structural and regular equivalence are both deterministic. Probability offers us yet another way of operationalizing the idea of equivalence, and one that is well-aligned with Bayesian probabilistic modelling. Nodes are <strong>stochastically equivalent</strong> if they have the same probabilities of connecting with other nodes. In other words, nodes are grouped into the same blocks if they are statistically indistinguishable from one another due to sharing similar probabilities of connecting with other nodes according to their stochastically equivalent blocks.</p>
<blockquote class="blockquote">
<p><strong>Further Reading</strong></p>
<p>Like the deterministic conception of equivalence, this stochastic conception was initially developed in the social sciences and statistics <span class="citation" data-cites="holland1983stochastic snijders1997estimation wang1987stochastic nowicki2001estimation">(see <a href="references.html#ref-holland1983stochastic" role="doc-biblioref">Holland, Laskey, and Leinhardt 1983</a>; <a href="references.html#ref-snijders1997estimation" role="doc-biblioref">Snijders and Nowicki 1997</a>; <a href="references.html#ref-wang1987stochastic" role="doc-biblioref">Wang and Wong 1987</a>; <a href="references.html#ref-nowicki2001estimation" role="doc-biblioref">Nowicki and Snijders 2001</a>)</span>, but over the same time period were developing in other sciences (a textbook example of “multiple discovery”); it is now very much an interdisciplinary affair at the cutting edge of network science <span class="citation" data-cites="peixoto2019bayesian">(see <a href="references.html#ref-peixoto2019bayesian" role="doc-biblioref">T. P. Peixoto 2019</a>)</span>.</p>
</blockquote>
</section>
<section id="blockmodels" class="level4" data-number="16.3.1.2">
<h4 data-number="16.3.1.2" class="anchored" data-anchor-id="blockmodels"><span class="header-section-number">16.3.1.2</span> Blockmodels</h4>
<p>Once we’ve adopted some operational definition of equivalence, the second step is to use that definition to cluster nodes into different equivalence classes. As previously mentioned, these classes represent generic <strong>positions</strong> and are typically referred to as “<strong>blocks</strong>.” The process of identifying these blocks is called “<strong>blockmodelling</strong>,” and there are a number of different ways it can be done <span class="citation" data-cites="doreian2005generalized doreian2002positional ferligoj2011positions peixoto2019bayesian snijders1997estimation">(see <a href="references.html#ref-doreian2005generalized" role="doc-biblioref">Doreian, Batagelj, and Ferligoj 2005</a>, <a href="references.html#ref-doreian2002positional" role="doc-biblioref">2002</a>; <a href="references.html#ref-ferligoj2011positions" role="doc-biblioref">Ferligoj, Doreian, and Batagelj 2011</a>; <a href="references.html#ref-peixoto2019bayesian" role="doc-biblioref">T. P. Peixoto 2019</a>; <a href="references.html#ref-snijders1997estimation" role="doc-biblioref">Snijders and Nowicki 1997</a>)</span>. The most important distinction is between deterministic and stochastic blockmodels. Unsurprisingly, deterministic blockmodels are used alongside deterministic understandings of equivalence, and stochastic blockmodels are used alongside stochastic understandings of equivalence.</p>
<p>The results of deterministic blockmodels are fully determined by (<em>i</em>) the parameters of the model, such as the number of blocks to look for, and (<em>ii</em>) the input data itself. Given the same parameter values and the same input data, the models will always produce the same results. Typically this is done by constructing a similarity or distance matrix from an adjacency matrix, and then performing some form of cluster analysis, such as hierarchical clustering, on that matrix. There have been many specific algorithms for blockmodelling introduced since Harrison White and his students first introduced the idea of structural equivalence and blockmodelling in the 1970s, the most famous of which are CONCOR and REGE. A discussion of these and other deterministic blockmodels is beyond the scope of this chapter, but they are described in most social network analysis methods texts.</p>
<p>By contrast, the blockmodels we will discuss in the rest of this chapter are <em>stochastic</em>, and are based on notions of <em>stochastic equivalence</em>. Let’s shift the discussion to them now.</p>
</section>
</section>
<section id="bayesian-hierarchical-stochastic-blockmodels" class="level3" data-number="16.3.2">
<h3 data-number="16.3.2" class="anchored" data-anchor-id="bayesian-hierarchical-stochastic-blockmodels"><span class="header-section-number">16.3.2</span> Bayesian Hierarchical Stochastic Blockmodels</h3>
<p>Unlike their deterministic counterparts, Bayesian stochastic blockmodels conceptualize network structure as a latent variable problem to be addressed with a generative model. Just as LDA assumes that specific combination of words observed in documents are <em>generated</em> from shared latent themes, SBMs assume that specific patterns of ties between nodes in social networks are <em>generated</em> from some latent network structure that influences the formation and dissolution of relationships. The types of latent structure that we are interested in varies, and we can develop models for specific types of structure.</p>
<p>Having a probabilistic model of how this works, grounded in plausible generative mechanisms, is an important part of developing models that don’t under or overfit our data. It helps us differentiate structure from random noise in the process of moving from concrete connections between concrete nodes to general connections between categories of nodes. This allows us to overcome some of the limitations of deterministic approaches, which can be tripped up by structure that is caused by random fluctuations rather than some meaningful network-driven social process.</p>
<p>Tiago <span class="citation" data-cites="peixoto2019bayesian">T. P. Peixoto (<a href="references.html#ref-peixoto2019bayesian" role="doc-biblioref">2019</a>)</span> summarizes the Bayesian response to this problem in one pithy paragraph:</p>
<blockquote class="blockquote">
<p>“The remedy to this problem is to think probabilistically. We need to ascribe to each possible explanation of the data a probability that it is correct, which takes into account modeling assumptions, the statistical evidence available in the data, as well as any source of prior information we may have. Imbued in the whole procedure must be the principle of parsimony – or Occam’s razor – where a simpler model is preferred if the evidence is not sufficient to justify a more complicated one” (page 4).</p>
</blockquote>
<p>As with LDA, the underlying logic of developing a Bayesian generative model here is the same as in other contexts. To continue drilling that underlying logic:</p>
<ol type="1">
<li>we have observed data (connections between nodes in a network) and unobserved latent variables (block or community membership);</li>
<li>we want to infer the distributions of the latent variables (i.e., the assignment of nodes into latent blocks) conditional on the observed data;</li>
<li>to do so, we construct a joint probability distribution of every possible combination of values for our latent and observed variables (i.e., the numerator in Bayes theorem) and then perform approximate posterior inference to determine the probabilities of different distributions on the latent variables conditional on the observed data.</li>
</ol>
<p>We are after the posterior probabilities of many different partitions of the network conditioned on the connections we observe. In other words, we want to know the conditional probability that some node partition <span class="math inline">\(b\)</span> could have plausibly generated an observed network <span class="math inline">\(G\)</span>,</p>
<p><span class="math display">\[\begin{align}
P(\text{b}|\text{G})
\end{align}\]</span></p>
<p>As with all Bayesian models, we need to play the “what’s that” game, providing priors for all latent variables. The natural tendency here is to prefer uniform priors. If you recall from Chapter 28, using a uniform distribution for our priors means assigning an equal probability to every possible value of the latent variable. <span class="citation" data-cites="peixoto2019bayesian">T. P. Peixoto (<a href="references.html#ref-peixoto2019bayesian" role="doc-biblioref">2019</a>)</span> has shown, however, that this strategy often results in suboptimal results with network models, as it has an a priori preference for solutions with number of blocks comparable to the number of nodes in the network. Who wants that? Nobody. Instead, <span class="citation" data-cites="peixoto2019bayesian">T. P. Peixoto (<a href="references.html#ref-peixoto2019bayesian" role="doc-biblioref">2019</a>)</span> proposes a three-level hierarchical Bayesian approach where we sample (1) the number of blocks, (2) the sizes of each block, and the (3) the partition of the observed network into those blocks.</p>
<p>This hierarchical model is much less likely to overfit our data, and it does so without requiring us to determine the number of groups in advance, or indeed making any assumptions about the higher-order structure of the networks we are interested in. We will use this model exclusively below. It’s known as a <strong>nested Stochastic Blockmodel</strong>. <span class="citation" data-cites="peixoto2014hierarchical">T. Peixoto (<a href="references.html#ref-peixoto2014hierarchical" role="doc-biblioref">2014</a>)</span> describes a number of interesting variations on inference algorithms for this hierarchical model. One <em>very</em> important thing to know about the SBM implementation in graph-tool is that rather than strictly considering equivalence, it also considers the probability of nodes connecting to other nodes, in the more standard sense of network models we’ve looked at previously. This means that the network partitions from graph-tool will be based on a mixture of assortative community structure (as we’ve seen in Chapter 15 with Louvain and Leiden) along with disassortative (structural equivalence). Incorporating edge weights into the SBM estimation tends to push the balance in the results towards the assortative side, which makes some intuitive sense - a highly weighted connection between two nodes could drown out the latent influence of structural equivalence. We will examine this shortly.</p>
<p>This has all been very abstract. Let’s get our hands dirty with some code.</p>
</section>
</section>
<section id="blockmodelling-with-graph-tool" class="level2" data-number="16.4">
<h2 data-number="16.4" class="anchored" data-anchor-id="blockmodelling-with-graph-tool"><span class="header-section-number">16.4</span> BLOCKMODELLING WITH GRAPH-TOOL</h2>
<p>When it comes to the fitting Bayesian stochastic blockmodels, there’s no beating Tiago Peixoto’s graph-tool, in Python or otherwise. It has astonishing performance in terms of both speed and memory, and as a result it can handle exceptionally large networks efficiently. This performance is achieved by offloading most of the heavy lifting to C++ on the back-end. The cost of these performance improvements, however, is that using graph-tool is less “Pythonic” than you might be used to by this point in the book. Graph-tool is considerably more complex than the network analysis packages we’ve seen so far (Networkx and NDLib).</p>
<p>The additional overhead and less Pythonic nature that gives graph-tool it’s superior performance capabilities also means that I have to spend more time upfront describing how things work. It is entirely possible some of this won’t really “sink in” until you start working with graph-tool. That’s OK! Once you get your hands dirty with some models and have built up a bit of intuition, you can always come back to this content to deepen your understanding.</p>
<section id="installing-graph-tool" class="level3" data-number="16.4.1">
<h3 data-number="16.4.1" class="anchored" data-anchor-id="installing-graph-tool"><span class="header-section-number">16.4.1</span> Installing graph-tool</h3>
<p>The easiest way to get up and running with graph-tool is to install it via conda-forge with the following command. Because of its numerous dependencies, I strongly recommend that you do this inside a Conda environment (such as the dcss environment, if you’ve been following along with the supplementary learning materials). As a reminder, Conda environments were introduced in Chapter 2.</p>
<p><code>conda install -c conda-forge graph-tool</code></p>
<p>If you haven’t been using an environment already, you can also install graph-tool inside a conda environment designed specifically for graph-tool. You can use that environment the same way you use any other conda environment. To download and activate the graph-tool environment, simple execute the following from the command line:</p>
<p><code>conda create --name gt -c conda-forge graph-tool</code></p>
<p>When conda prompts you for permission to download and install the required packages, agree. When it’s finished, activate the environment with</p>
<p><code>conda activate gt</code></p>
<p>When you do so, you should see your command prompt change; it will now start with <code>(gt)</code> (as opposed to <code>dcss</code> if you’ve been using the conda environment for this book). If you are using Jupyter, note that you’ll have to launch your Jupyter Notebook server inside that environment to access the packages inside the environment.</p>
</section>
<section id="understanding-property-maps" class="level3" data-number="16.4.2">
<h3 data-number="16.4.2" class="anchored" data-anchor-id="understanding-property-maps"><span class="header-section-number">16.4.2</span> Understanding Property Maps</h3>
<p>The most important graph-tool concept to understand is how its array-like “property maps” work. Rather than attaching information about a node (e.g., its ID / label or degree centrality) to the node itself, each node in the network is assigned a unique index. That same index is contained in a property map, and whenever we want to know some information about a node, we use the node index to find the relevant information in the property map. There’s a bit of extra friction here, though: because of the C++ backend, each property map object contains <em>only one type of data</em>, that you have to declare in advance. This is a pain, but it’s what allows us to enjoy some pretty remarkable performance improvements.</p>
<p>Because graph-tool makes such heavy use of these array-like property maps, it’s easiest to think of a network in graph-tool as a collection of <em>associated arrays</em>. For example, in a network with three nodes – <code>['Lebron James', 'Anthony Davis', 'Kentavious Caldwell-Pope']</code> – and an associated property map of colours – <code>[Red, Green, Blue]</code> – <code>Lebron James</code> would be <code>Red</code>, <code>Antony Davis</code> would be <code>Green</code>, and <code>Kentavious Caldwell-Pope</code> would be <code>Blue</code>. We can encode just about anything in a property map, including vectors of values. For example, the <code>[Red, Green, Blue]</code> property map could also be stored as RGB values, <code>[[255,0,0], [0,128,0], [0,0,255]]</code>, which would associate <code>[255,0,0]</code> with <code>Lebron James</code>.</p>
<p>It’s also very important to note that</p>
<ol type="1">
<li>graph-tool does not automatically label nodes, and</li>
<li>it is possible for multiple nodes can have the same label.</li>
</ol>
<p>This can result in some unwelcome surprises. For example, if your edgelist contains strings <strong>as opposed to numbers</strong> – such as</p>
<pre><code>[
    ('Karamo', 'Tan'), 
    ('Karamo', 'Tan')
]</code></pre>
<p>then graph-tool will create four different nodes and two edges rather than creating two nodes and aggregating the edges into a weight of 2 for the tie between Karamo and Tan.</p>
<p>You might recall from Chapter 14 that different disciplines tend to use different words to refer to nodes and edges. In graph-tool, <strong>nodes are referred to as vertices</strong>. They are <em>exactly</em> the same. When we create a new vertex in graph-tool – <code>v = g.add_vertex()</code> – <code>v</code> becomes a <code>vertex</code> class object, which we can refer to as a <strong>vertex descriptor</strong>. Vertex descriptors are alternative to node indices and can be used to access information about a node from a property map. If we assigned our <code>[Red, Green, Blue]</code> property map to an object called <code>colour_map</code>, we could retrieve the information for node <code>v</code> with <code>colour_map[v]</code>.</p>
<p>Edge property maps, which can contain useful information such as edge weight, behave somewhat differently. They are accessed using <strong>edge descriptors</strong>, which can be obtained from the source and target nodes. For example, we might obtain and store an edge descriptor between nodes <code>Karamo</code> and <code>Tan</code> with <code>e = g.edge('Karamo','Tan')</code> or <code>e = g.edge(1, 2)</code> if you’ve assigned Karamo and Tan integer IDs to benefit from faster compute times.</p>
<p>Finally, entire networks can themselves can have property maps. These network-level property maps can be accessed by passing the graph object itself. For example, if we have a network object called <code>g</code> and a property map called <code>graph_property_map</code>, we could access the properties with <code>graph_property_map[g]</code>.</p>
<p>This might sound like a lot of additional overhead to worry about when conducting a network analysis, but you’ll likely find the impact fairly minimal once you get used to things. As with other network analysis packages, it makes it relatively easy to do a large amount of data processing outside of the package itself. For example, you can do a lot of work with the data that will eventually be stored as property maps using Pandas and Numpy. My main advice here is <em>take great care that all of the data in your lists and arrays are in the same order, and of equal lengths.</em></p>
<p>Now, let’s model.</p>
</section>
<section id="imports" class="level3" data-number="16.4.3">
<h3 data-number="16.4.3" class="anchored" data-anchor-id="imports"><span class="header-section-number">16.4.3</span> Imports</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> graph_tool.<span class="bu">all</span> <span class="im">import</span> <span class="op">*</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>pd.set_option(<span class="st">"display.notebook_repr_html"</span>, <span class="va">False</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pickle</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dcss.networks <span class="im">import</span> label_radial_blockmodel, get_block_membership</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="data" class="level3" data-number="16.4.4">
<h3 data-number="16.4.4" class="anchored" data-anchor-id="data"><span class="header-section-number">16.4.4</span> Data</h3>
<p>As usual, I suggest refreshing yourself on the data we are using here by returning to the overview of datasets from Chapter 1. In brief, the Enron email data is provided as two CSV files, one with the edges between employees who have exchanged emails with one another, and one with the organizational position of Enron employees.</p>
<p>When developing a blockmodel, we typically do so without having some external set of positions or roles that we want to approximate; the goal here is not supervised learning. However, for learning purposes, our goal will be to develop a blockmodel using relational data that mirrors job titles. The purpose of doing things this way is to illustrate the power of this approach to network analysis, as well as make the discussion of “positions” a bit less abstract. So, remember that when we talk about “positions” and “roles,” we don’t always (or even often) mean <em>official</em> positions or roles such as job titles.</p>
<p>The two datasets below contain the relational data from employee email communications and information about the job title each employees held in the organization.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>edges_df <span class="op">=</span> pd.read_csv(<span class="st">'data/enron/enron_full_edge_list.csv'</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>edges_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>                      source                             target
0    press.release@enron.com            all.worldwide@enron.com
1  office.chairman@enron.com             all.downtown@enron.com
2  office.chairman@enron.com      all.enron-worldwide@enron.com
3    press.release@enron.com            all.worldwide@enron.com
4  office.chairman@enron.com  all_enron_north.america@enron.com</code></pre>
<p>As you can see, our edgelist has two columns, <code>source</code> and <code>target</code>. We don’t have any edge weights (though we will compute them below) or other edge attributes.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>employee_df <span class="op">=</span> pd.read_csv(<span class="st">'data/enron/enron_employees_updated.csv'</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>employee_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>                           id                  position
0        liz.taylor@enron.com  Administrative Assistant
1    michelle.lokay@enron.com  Administrative Assistant
2  holden.salisbury@enron.com                   Analyst
3        kam.keiser@enron.com                   Analyst
4   matthew.lenhart@enron.com                   Analyst</code></pre>
<p>The information about each employee’s <em>official</em> position in the organization is provided in a column called <code>'position'</code>. Let’s count the number of employees in each role.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>employee_df[<span class="st">'position'</span>].value_counts()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Trader                      35
Vice President              26
Director                    17
Manager                     15
In House Lawyer             11
Senior Specialist            8
Specialist                   6
Managing Director            6
Analyst                      5
Employee                     5
President                    4
CEO                          4
Administrative Assistant     2
Associate                    2
Senior Manager               1
COO                          1
CFO                          1
Name: position, dtype: int64</code></pre>
<section id="constructing-the-communication-network" class="level4" data-number="16.4.4.1">
<h4 data-number="16.4.4.1" class="anchored" data-anchor-id="constructing-the-communication-network"><span class="header-section-number">16.4.4.1</span> Constructing the Communication Network</h4>
<p>To create our network, let’s construct a weighted communication network between core employees using the edgelist and node attribute files above. First, we’ll aggregate and count edges to compute a weight. We’ll ignore any nodes that are not in the <code>employee_df</code> dataframe, narrowing our focus to core employees only. The “core employees” are those who were involved the legal proceedings following the Enron scandal.</p>
<p>Since this is a <strong>directed communication network</strong>, <code>i,j</code> ties are different than <code>j,i</code> ties, so we can simply aggregate our edges dataframe by the combination of <code>'source'</code> and <code>'target'</code> columns and treat the count of their occurrences as our edge weight. We’ll also filter the resulting dataframe so that it only includes nodes that are part of the core employee subset.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>edges_df <span class="op">=</span> edges_df.value_counts([<span class="st">'source'</span>, <span class="st">'target'</span>]).reset_index(name<span class="op">=</span><span class="st">'count'</span>).copy()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>core_employees <span class="op">=</span> <span class="bu">set</span>(employee_df[<span class="st">'id'</span>].tolist())</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>core_edges_df <span class="op">=</span> edges_df[edges_df[<span class="st">'source'</span>].isin(core_employees) <span class="op">&amp;</span> </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>                         edges_df[<span class="st">'target'</span>].isin(core_employees)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With our weighted directed edgelist created, we can initialize a directed network.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>eG <span class="op">=</span> Graph(directed <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can add the core employees to this network as nodes, add their job titles to a property map, and add the edge data (weights) to a property map. We’ll do that in three steps:</p>
<ol type="1">
<li>get the information into lists,</li>
<li>initialize the property maps and tell graph-tool what type of data they we are going to provide, and</li>
<li>loop over our two lists to add the employees to the networks and their node and edge attributes (job titles, edge weights) to property maps.</li>
</ol>
<p>First, create the lists!</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>employee_list <span class="op">=</span> employee_df[<span class="st">'id'</span>].tolist()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>title_list <span class="op">=</span> employee_df[<span class="st">'position'</span>].tolist()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Second, initialize the property maps! Note that in addition to the property maps themselves, we are creating a dictionary called <code>vertex_lookup</code>. As mentioned earlier in the chapter, we can use this to dictionary to simplify the ‘lookup’ process to select nodes using string values that carry some meaning about the node, rather than the integer identifier used by graph-tool.</p>
<p>Since we are going to use email addresses as node labels, we’ll initialize a property map called <code>labels</code> and tell graph-tool to expect strings (because email addresses are strings). Similarly we will initialize a property map for job titles, called <code>titles</code>, and also containing strings. Finally, we will create an <code>edge_weight</code> property map. Since edge weights are integers in this case, we will tell graph-tool to expect integers.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>vertex_lookup <span class="op">=</span> {}</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>label <span class="op">=</span> eG.new_vertex_property(<span class="st">'string'</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>title <span class="op">=</span> eG.new_vertex_property(<span class="st">'string'</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>edge_weight <span class="op">=</span> eG.new_edge_property(<span class="st">'int'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we’re ready to add information to the property maps! Let’s zip up our <code>employee_list</code> and <code>title_list</code> and then iterate over it. For each pairing of elements from the two lists, we’ll add the core employees to the network as nodes, their email addresses to the <code>labels</code> property map, and their job titles to the <code>titles</code> property map. Finally, we will add the information about the node index to the <code>vertex_lookup</code> dict we created above.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> vertex <span class="kw">in</span> <span class="bu">zip</span>(employee_list, title_list):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create a new vertex instance</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> eG.add_vertex()</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add attributes to the property maps in the index position of the vertex</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    label[v] <span class="op">=</span> vertex[<span class="dv">0</span>]</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    title[v] <span class="op">=</span> vertex[<span class="dv">1</span>]</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add the vertex to the lookup dictionary, converting it to an integer </span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    vertex_lookup[vertex[<span class="dv">0</span>]] <span class="op">=</span> <span class="bu">int</span>(v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As you probably anticipated, the next thing we need to do is process the edges between nodes. We can do that by using lists pulled from the edges dataframe, but remember we <em>also</em> need to consult <code>vertex_lookup</code> to ensure we are assigning the right edges between the right nodes!</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>source_list <span class="op">=</span> core_edges_df[<span class="st">'source'</span>].tolist()</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>target_list <span class="op">=</span> core_edges_df[<span class="st">'target'</span>].tolist()</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>weight_list <span class="op">=</span> core_edges_df[<span class="st">'count'</span>].tolist()</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> nodes <span class="kw">in</span> <span class="bu">zip</span>(source_list, target_list, weight_list):</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    from_idx <span class="op">=</span> vertex_lookup[nodes[<span class="dv">0</span>]]</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    to_idx <span class="op">=</span> vertex_lookup[nodes[<span class="dv">1</span>]]</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Let's ignore self-loops</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> from_idx <span class="op">!=</span> to_idx:</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        edge <span class="op">=</span> eG.add_edge(from_idx, to_idx)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        edge_weight[edge] <span class="op">=</span> nodes[<span class="dv">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ve now reached the very final bit of preparation. We’ll make each of the property maps we’ve just initialized and populated with information <em>internal to the graph</em> and save the graph in <code>graph-tool</code>’s own format. That way we don’t need to recreate the network again later, we can just load up the network with all the relevant property maps already defined.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>eG.vertex_properties[<span class="st">'label'</span>] <span class="op">=</span> label</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>eG.vertex_properties[<span class="st">'title'</span>] <span class="op">=</span> title</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>eG.edge_properties[<span class="st">'edge_weight'</span>] <span class="op">=</span> edge_weight</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>lookup <span class="op">=</span> eG.new_graph_property(<span class="st">'object'</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>lookup[eG] <span class="op">=</span> vertex_lookup</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>eG.graph_properties[<span class="st">'vertex_lookup'</span>] <span class="op">=</span> lookup</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And with that, we’re ready to start developing stochastic blockmodels!</p>
</section>
</section>
<section id="developing-stochastic-blockmodels" class="level3" data-number="16.4.5">
<h3 data-number="16.4.5" class="anchored" data-anchor-id="developing-stochastic-blockmodels"><span class="header-section-number">16.4.5</span> Developing Stochastic Blockmodels</h3>
<p>In the introduction, we discussed how there are some properties that stochastic blockmodels share with LDA. One of those properties is the process for developing, critiquing, improving, and eventually selecting the best model in an iterative fashion: Box’s loop. For example, in this case, after approximating the posterior distribution of the latent variables, we can test the fit of that posterior on the data, and repeat the process using the insight gained about what is and isn’t working in the model. In theory, enough iterations would produce the best model possible in terms of representing the data (<em>not</em> in terms of the usefulness of the results). In practice, we have to make a choice about when we’re satisfied with the results, because there’s no good way to know how many iterations it would take to produce the best model you can given the data you have.</p>
<p>As I mentioned earlier, our goal here is to develop a blockmodel that will partition our network into a set of positions that mirror the job titles that the core employees held within Enron. The catch, of course, is that we want to do this using only information from the relational data itself.</p>
<p>graph-tool has a very handy function, <code>minimize_nested_blockmodel_dl()</code>, that takes care of all the hard work for us. It’s fast to run, and tends to produce good results right out of the box. <code>minimize_nested_blockmodel_dl()</code> attempts to minimize something called the “<strong>description length</strong>” of a nested blockmodel. Let’s break this down, starting with the nested part. As you hopefully recall from earlier in this chapter, a <em>nested</em> stochastic blockmodel is a hierarchical Bayesian model. In other words, it embeds blocks inside other blocks in a <strong>multi-level hierarchy</strong>. Doing things this way makes it easier to find small blocks in a network that may contain a small number of nodes.</p>
<p>The <code>minimize</code> and <code>dl</code> parts of <code>minimize_nested_blockmodel_dl()</code> are a shorthand for <strong>minimize the description length</strong>. Minimum description length is an operationalization of Occam’s razor; it suggests that the best model is one that can represent all of the data with the least amount of information required. It helps us select a model that fully explains the data but is as simple as possible given the observed data.</p>
<p>Finally, the blockmodel we will fit here is also <strong>degree-corrected</strong> <span class="citation" data-cites="karrer2011stochastic">(<a href="references.html#ref-karrer2011stochastic" role="doc-biblioref">Karrer and Newman 2011</a>)</span>. A standard baseline SBM assumes that nodes within any given block tend to have very similar, if not identical, degrees. Since this is <em>extremely unrealistic</em> in real world networks, it is almost always better to use the degree-corrected implementation.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> minimize_nested_blockmodel_dl(eG, deg_corr <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With that one line of code, we’ve executed our 3-level Hierarchical Bayesian Stochastic Blockmodel!</p>
<p>The function we just executed created something called a <strong>blockstate</strong>, which is an object containing the results of partitioning the network running our blockmodel. We can print a summary of the blockstate for our nested degree-corrected description-length-minimized blockmodel to find out</p>
<ul>
<li>the number of blocks that nodes were assigned to,</li>
<li>the number of levels in the nested hierarchy, and</li>
<li>the number of “<strong>meta-blocks</strong>” at each of those levels (blocks within blocks in the nested hierarchy).</li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>state.print_summary()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>l: 0, N: 149, B: 13
l: 1, N: 13, B: 4
l: 2, N: 4, B: 1</code></pre>
<p>Remember that the model we just ran is a <em>stochastic generative model</em>, so the number of blocks will vary for each run of the model, but it typically finds 12-14 blocks at the bottom level. Remember, this is a nested variant where the “bottom level” consists of all the individual nodes, while the upper levels of the hierarchy are aggregate blocks, found by creating a new network where each block is a node and estimating a blockmodel based on that network. After some consideration, 12-14 blocks seems fairly reasonable. We have 17 job titles in the data but if we combined “Manager + Senior Manager”, “Senior Specialist + Specialist”, “Administrative Assistant + Employee”, and “CEO + CFO + COO”, we’d have 12 titles. This kind of combination would not impact the computation of the model at all and can be left until it’s time for interpretation.</p>
<p>Finally, we can get a quick sense of how things went by visualizing the blockmodel (Figure <span class="quarto-unresolved-ref">?fig-31_01</span>). I’m limited to a narrow colour palette in print, but you can access a full resolution colour version of the image (and others like it) in the supplementary online materials. I recommend looking at the color versions of these images, as colour is used very effectively in these blockmodel visualizations.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>state.draw(</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    layout <span class="op">=</span> <span class="st">"sfdp"</span>, </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    vertex_text <span class="op">=</span> eG.vertex_properties[<span class="st">'title'</span>], </span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    eorder <span class="op">=</span> eG.edge_properties[<span class="st">'edge_weight'</span>],</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    vertex_text_position <span class="op">=</span> <span class="dv">315</span>,</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">1</span>],</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>[<span class="dv">4024</span>,<span class="dv">4024</span>],</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    output<span class="op">=</span><span class="st">'figures/core_enron_blockmodel_sfdp.pdf'</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="figures/core_enron_blockmodel_sfdp1.pdf" class="img-fluid"></p>
<figcaption class="figure-caption">Cap</figcaption>
</figure>
</div>
<p>In this figure, each node is represented by an individual point (as in other network visualiztions), only the nodes are organized into blocks. The squares are points where blocks converge up the hierarchy to form the nested structure - the structure of email exchanges between blocks will decide whether a block should be grouped with another one. For example, if you look at the group of 6 blocks in the top left of the image, you might notice that there are only two traders present, but there are a lot of lawyers and vice presidents, as well as a CEO.</p>
<p>This first attempt is already looking pretty good. We have 3 of the 4 CEOs in the same block near the right-hand side, along with three presidents. Note for later: the remaining CEO isn’t in the same meta-block - one level up the hierarchy - as the other CEOs.</p>
<p>As with other generative models, <em>we need to think through generative mechanisms here</em>. If you recall from Chapter 25, all this really means is that we need to think through simple social and interactional processes that may have resulted in (i.e., generated) the patterns we see in our data. <em>What’s a plausible story of how this data was generated?</em></p>
<p>Remember that we are detail with <em>email communication</em> between employees in an organization here. There are many ways to imagine the social mechanisms that best predict structure in a network like this. In this case, it could be that emails between the core employees predicts the relationship between those employees, or it could be that the emails they send <em>to other non-core employee Enron email addresses</em> are more predictive. This is an exploratory process that can’t fit reasonably in this chapter, but you can see a bit of it in the online supplement.</p>
<p>Let’s see what the outcome is with different blockmodel estimation criteria. Stochastic blockmodels in graph-tool are able to incorporate edge weights into the estimation.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>state_w <span class="op">=</span> minimize_nested_blockmodel_dl(eG, deg_corr <span class="op">=</span> <span class="va">True</span>, </span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>                                              state_args<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>                                                  recs<span class="op">=</span>[eG.edge_properties[<span class="st">'edge_weight'</span>]],</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>                                                  rec_types<span class="op">=</span>[<span class="st">"discrete-binomial"</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>state_w.print_summary()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>l: 0, N: 149, B: 67
l: 1, N: 67, B: 10
l: 2, N: 10, B: 2
l: 3, N: 2, B: 1</code></pre>
<p>We can see already that we end up with far too many blocks to be useful here! There’s no need to visualize this graph, but we have another option - let’s try setting the number of blocks to be the same as it was for the unweighted model, then see what the weights do for the results.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>state_w2 <span class="op">=</span> minimize_nested_blockmodel_dl(eG, deg_corr <span class="op">=</span> <span class="va">True</span>, B_min<span class="op">=</span><span class="dv">12</span>, B_max<span class="op">=</span><span class="dv">12</span>,</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>                                              state_args<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>                                                  recs<span class="op">=</span>[eG.edge_properties[<span class="st">'edge_weight'</span>]],</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>                                                  rec_types<span class="op">=</span>[<span class="st">"discrete-binomial"</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>state_w2.print_summary()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>l: 0, N: 149, B: 12
l: 1, N: 12, B: 3
l: 2, N: 3, B: 2
l: 3, N: 2, B: 1</code></pre>
<p>At first glance (Figure <span class="quarto-unresolved-ref">?fig-31_02</span>), incorporating edge weight seems as though it produces more tightly-knit, smaller blocks, and only two distinct groups of blocks one level up the hierarchy where we had four with the first model. The larger blocks are also more heterogenous, with CEO’s grouped alongside many traders and even “employees”.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>state_w2.draw(</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    layout <span class="op">=</span> <span class="st">"sfdp"</span>, </span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    vertex_text <span class="op">=</span> eG.vertex_properties[<span class="st">'title'</span>], </span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    eorder <span class="op">=</span> eG.edge_properties[<span class="st">'edge_weight'</span>],</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    vertex_text_position <span class="op">=</span> <span class="dv">315</span>,</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">1</span>],</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>[<span class="dv">4024</span>,<span class="dv">4024</span>],</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    output<span class="op">=</span><span class="st">'figures/core_enron_blockmodel_sfdpw.pdf'</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="figures/core_enron_blockmodel_sfdpw1.pdf" class="img-fluid"></p>
<figcaption class="figure-caption">Cap</figcaption>
</figure>
</div>
<p>The use of edge weights in a blockmodel is a theoretical consideration more than it is a technical one, so it takes some careful thought and experimenting to see what the impact is. In our case, we have people with quite different roles in the company, so their email volume will be quite different. If we don’t use edge weights, we stick to a stricter definition of equivalence, closer to structural, and here this produces the most intuitive results. Nonetheless, we should have a way to compare the results beyond just looking at a graph - these graphs won’t be very helpful for huge networks. We can use the <code>get_block_membership</code> utility from the dcss package to add block assignment information to the employee dataframe.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>employee_blocks_df <span class="op">=</span> get_block_membership(state, eG, employee_df,</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>                                         <span class="st">'model_uw_1'</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>employee_blocks_df <span class="op">=</span> get_block_membership(state_w2, eG, employee_blocks_df,</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>                                         <span class="st">'model_w_2'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s take a look at some of the job titles that one would expect to be more well-defined.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>df_by_position <span class="op">=</span> employee_blocks_df.groupby(<span class="st">'position'</span>).agg(<span class="bu">list</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>df_by_position[df_by_position.index.isin([<span class="st">'CEO'</span>,<span class="st">'President'</span>, <span class="st">'In House Lawyer'</span>])].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>                                                                id  \
position                                                             
CEO              [david.w.delainey@enron.com, jeff.skilling@enr...   
In House Lawyer  [bill.rapp@enron.com, carol.clair@enron.com, d...   
President        [greg.whalley@enron.com, jeffrey.a.shankman@en...   

                                 model_uw_1_block_id  \
position                                               
CEO                                     [5, 5, 0, 0]   
In House Lawyer  [1, 9, 10, 10, 9, 7, 5, 3, 9, 9, 3]   
President                              [5, 5, 0, 12]   

                                model_w_2_block_id  
position                                            
CEO                                   [0, 5, 1, 5]  
In House Lawyer  [9, 9, 0, 8, 2, 8, 3, 5, 6, 1, 6]  
President                             [2, 2, 1, 5]  </code></pre>
<p>You might be able to get a sense of things from some of the smaller lists here. For example, in the <code>model_uw_1_block_id</code> column, we can see that one block has 3 of the 4 CEOs, as well as 3 of the 4 Presidents, while another has the remaining CEO and President. 6 of the lawyers also tend to end up in the same block on this run (again, this is stochastic so results might vary a little bit). With the weighted model, only two of the CEOs end up in the same block, although they are joined by a President and a lawyer.</p>
<p>Alternatively, we can count the number of unique block assignments by role (job title) and calculate the average, based on the number of people with those roles. A lower value here would be a loose indicator of accuracy, with two caveats: a 0.5 value for CEO would be the same if the 4 CEOs were divided equally into two blocks, rather than 3 in one block and 1 in another. This block assignment difference is conceptually significant, so a more robust metric might be desirable. Job titles that apply to only 1 employee will also, necessarily, have a perfectly poor score of 1.0 every time.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>employee_blocks_df.groupby([<span class="st">'position'</span>])[<span class="st">'model_uw_1_block_id'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>position
Administrative Assistant    1.000000
Analyst                     0.400000
Associate                   1.000000
CEO                         0.500000
CFO                         1.000000
COO                         1.000000
Director                    0.411765
Employee                    0.600000
In House Lawyer             0.545455
Manager                     0.466667
Managing Director           0.666667
President                   0.750000
Senior Manager              1.000000
Senior Specialist           0.875000
Specialist                  0.500000
Trader                      0.200000
Vice President              0.423077
Name: model_uw_1_block_id, dtype: float64</code></pre>
<div class="sourceCode" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(employee_blocks_df.groupby([<span class="st">'position'</span>])[<span class="st">'model_uw_1_block_id'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count()).<span class="bu">sum</span>())</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(employee_blocks_df.groupby([<span class="st">'position'</span>])[<span class="st">'model_w_2_block_id'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count()).<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>11.338629507747154
11.916386064915477</code></pre>
<p>We can do the exact inverse to roughly assess the homogeneity of the blocks, by reversing the columns in the groupby operation.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>employee_blocks_df.groupby([<span class="st">'model_uw_1_block_id'</span>])[<span class="st">'position'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>model_uw_1_block_id
0     0.750000
1     0.583333
2     0.277778
3     0.476190
4     0.555556
5     0.416667
6     0.230769
7     0.625000
8     0.714286
9     0.400000
10    0.666667
11    0.500000
12    0.666667
Name: position, dtype: float64</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(employee_blocks_df.groupby([<span class="st">'model_uw_1_block_id'</span>])[<span class="st">'position'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count()).<span class="bu">sum</span>())</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(employee_blocks_df.groupby([<span class="st">'model_w_2_block_id'</span>])[<span class="st">'position'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count()).<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6.862912087912089
7.970732305329079</code></pre>
<p>This loose evaluation suggests that the unweighted model might be preferred, but we can do better with this evaluation. Sci-kit learn provides <em>many</em> classification evaluation metrics and the problem we’re solving here is essentially a clustering classification. There are metrics within sklearn’s clustering section that provide the above evaluations but with more nuance (remember the equivalent 0.5 score if the CEOs were clustered with different proportions but the same number of blocks). A <code>homogeneity_score</code> evaluates, you guessed it, the homogeneity of the detected clusters, so if clusters contain more of the same type of job title, the results will score higher. Scores here are on a scale from 0 to 1, with 1 being the best.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> homogeneity_score, completeness_score, adjusted_mutual_info_score</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s compare homogeneity scores for the unweighted network and then the weighted one. As with the rough evaluation above, the unweighted model has a better score.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>homogeneity_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_1_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.353428152904928</code></pre>
<div class="sourceCode" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>homogeneity_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_w_2_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.25528558562493037</code></pre>
<p>The <code>completeness_score</code> inverts the previous score, instead assessing the homogeneity of block assignments for each job titles, so the degree to which nodes are assigned to blocks with other nodes that have the same title. The result is actually very similar in this case!</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>completeness_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_1_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.3435558493343224</code></pre>
<div class="sourceCode" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>completeness_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_w_2_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.2771316517440044</code></pre>
<p>Finally, we can also do both of the above in a unified score, <code>adjusted_mutual_info_score</code>, where homogeneity and completeness are considered together and the position of the ground-truth and predicted labels doesn’t matter. This can also be used to calculate agreement between two labelling methods, when there is no known ground-truth, but unfortunately our block assignment classifications will not be the same between models - <code>block 1</code> in one model is not necessarily the same as <code>block 1</code> in the next, or even in repeat runs of the same model. Note that this method is a version of <code>normalized_mutual_info_score</code> that is adjusted to account for chance, because the standard mutual information score tends to overestimate the shared information between models that have a larger number of clusters.</p>
<p>For this score, the maximum is 1 but it is possible to have a negative score if the predicted clusters are nonsensical enough. We can see that the adjusted mutual info score below is roughly half of the individual scores above, for the unweighted network. For the weighted network, the score is <em>much</em> lower. If we compare the two block assignments together, they actually have more agreement with each other than the weighted model has with the ground truth job titles.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>adjusted_mutual_info_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_1_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.15309516996415473</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>adjusted_mutual_info_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_w_2_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.0756412457785869</code></pre>
<div class="sourceCode" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>adjusted_mutual_info_score(employee_blocks_df[<span class="st">'model_w_2_block_id'</span>], employee_blocks_df[<span class="st">'model_uw_1_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.15563023649762936</code></pre>
<p>With this information in mind, let’s continue on with the unweighted network to see if we can optimize it more, then examine the end result.</p>
</section>
<section id="model-selection-and-optimization" class="level3" data-number="16.4.6">
<h3 data-number="16.4.6" class="anchored" data-anchor-id="model-selection-and-optimization"><span class="header-section-number">16.4.6</span> Model Selection and Optimization</h3>
<p>Given the stochastic nature of these models, it is always advisable to run them a number of times and then select the model with the least entropy. Higher entropy is not <em>inherently</em> bad. <strong>Properly discuss entropy here, and why we care</strong>. For example, a compressed JPEG image with only two colours will have a lot less entropy than one with a thousand colours.</p>
<p>In the case of stochastic block models, entropy returns the minimum description length, which is the amount of information the model needs to recreate the entire network. The goal of reducing entropy is fundamental to these models, with the assumption that minimizing entropy results in simpler models that do a better job of uncovering latent similarities in the data without overfitting. Below, we’ll execute 10 runs of <code>minimize_nested_blockmodel_dl</code> and print the entropy for each.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> [minimize_nested_blockmodel_dl(eG, deg_corr<span class="op">=</span><span class="va">True</span>) </span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>)]</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s <span class="kw">in</span> states:</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(s.entropy())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6162.281933127059
6187.135324492942
6168.918484063684
6161.190122173799
6163.517013260514
6162.876759036053
6178.052196472743
6154.1481501809185
6166.798460034726
6154.869718381805</code></pre>
<p>We can automatically grab the lowest entropy state using <code>np.argmin</code>.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> states[np.argmin([s.entropy() <span class="cf">for</span> s <span class="kw">in</span> states])]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="more-mcmc" class="level3" data-number="16.4.7">
<h3 data-number="16.4.7" class="anchored" data-anchor-id="more-mcmc"><span class="header-section-number">16.4.7</span> More MCMC</h3>
<p>At the expense of increased runtime, we can also follow-up the above model selection process by sampling from the posterior distribution and running <code>mcmc_equilibrate</code>, which performs random changes in the block assignments of the nodes, automatically handles the entropy calculations, and chooses the optimum values at the end. This step is also required to collect the block assignment posterior marginals, which tell us the likelihood (if any) that a node belongs to each block, based on the assignments it was given during the iterations. More iterations here will always improve the model, but with decreasing improvement/run-time payoffs.</p>
<p>First, we will use the object <code>S1</code>, defined below, to keep track of the original entropy score to see how much we improved the model.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>S1 <span class="op">=</span> state.entropy()</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>S1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6154.1481501809185</code></pre>
<p>To collect marginal probabilities with MCMC, the blockstate needs to have been prepared for sampling, rather than for minimizing description length, which we can achieve by copying the blockstate and setting sampling to <code>True</code>. At the same time, we will add an additional 4 empty levels to the nested hierarchy so that the model has a chance to assign more levels. If these hierarchy levels don’t improve the model, the equilibration method will collapse them.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> state.copy(bs<span class="op">=</span>state.get_bs() <span class="op">+</span> [np.zeros(<span class="dv">1</span>)] <span class="op">*</span> <span class="dv">4</span>,sampling <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’re going to perform many iterations of the <code>mcmc_equilibrate</code> function, where nodes are moved between different blocks. Importantly, the MCMC method used in graph-tool doesn’t perform fully random moves, which would be a fairly typical MCMC approach. By taking advantage of the assumption that networks are made up of heavily interdependant observations, the MCMC estimation only has to randomly sample from probable block assignment moves - to the blocks that a node’s alters are members of.</p>
<p>We create a callback function to pass to <code>mcmc_equilibrate</code> so that we can collect a set of block assignment choices from each iteration. The <code>bs</code> values can be thought of as votes for block re-assignment, and constitute the posterior marginal probability of each node’s assignment to each block.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>bs <span class="op">=</span> []</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="co">## OUR CALLBACK FUNCTION THAT APPENDS EACH ESTIMATED BLOCKSTATE TO THE ARRAY</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> collect_partitions(s):</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> bs</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    bs.append(s.get_bs())</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>mcmc_equilibrate(state, force_niter<span class="op">=</span><span class="dv">10000</span>, mcmc_args<span class="op">=</span><span class="bu">dict</span>(niter<span class="op">=</span><span class="dv">10</span>), callback<span class="op">=</span>collect_partitions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>(6159.927069603201, 37378153, 4808499)</code></pre>
<p>Note that this will sometimes result in higher entropy for the block model solution! That’s because we need to select the best partition from the ones added to the <code>bs</code> list by the callback function.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>state.entropy() <span class="op">-</span> S1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>5.778919422760737</code></pre>
<p>The <code>PartitionModeState</code> function takes our set of labeled partitions and tries to align them into a single set of common group labels. We can then use the <code>get_marginal()</code> method of the returned object to create a vertex property map of marginal probabilities for our original network graph. This property map can be used for calculations as well as for visualization of probable block memberships.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>pmode <span class="op">=</span> PartitionModeState(bs, nested<span class="op">=</span><span class="va">True</span>, converge<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>pv <span class="op">=</span> pmode.get_marginal(eG)</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>eG.vertex_properties[<span class="st">'pv'</span>] <span class="op">=</span> pv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, the convenience function <code>get_max_nested()</code> returns the most likely block assignment for each node as a single final blockstate, which will group nodes in proximity to each other in our visualization, based on their most likely membership. We apply this result back to our original blockstate object by providing it to the <code>copy()</code> method of the state object. Note that our entropy has improved a bit more here!</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>bs <span class="op">=</span> pmode.get_max_nested()</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> state.copy(bs<span class="op">=</span>bs)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>state.entropy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6153.278269237107</code></pre>
<p>Let’s re-calculate the same mutual information scores we used earlier to see if things have improved on those criteria.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>employee_blocks_df <span class="op">=</span> get_block_membership(state, eG, employee_blocks_df, <span class="st">'model_uw_mcmc'</span>)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>homogeneity_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_mcmc_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.38131989351325507</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>completeness_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_mcmc_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.3526819549124348</code></pre>
<p>Homogeneity improves from 0.35 to almost 0.39, while completeness only improves a small amount.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>adjusted_mutual_info_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_mcmc_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.1561547346951431</code></pre>
<p>But the adjusted mutual info score below is actually slightly worse than it was before! This doesn’t necessarily mean the results are worse, though. We’ll take a look at a different layout for the blockmodel below and discuss some potential explanations for this.</p>
</section>
<section id="visualizing-block-connections-as-a-radial-tree" class="level3" data-number="16.4.8">
<h3 data-number="16.4.8" class="anchored" data-anchor-id="visualizing-block-connections-as-a-radial-tree"><span class="header-section-number">16.4.8</span> Visualizing Block Connections as a Radial Tree</h3>
<p>While the sfdp layout does a nice job of positioning nodes (and blocks) in spatial relation to each other, the radial tree layout can be very helpful for getting a sense of the connection patterns between the blocks and also keeps nodes together in a way that makes individual blocks very easy to distinguish. Since it is the default layout for printing a block state, we can easily obtain a simple representation using the <code>.draw()</code> method (see Figure <span class="quarto-unresolved-ref">?fig-31_03</span>).</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>state.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="chapter_31_latent_network_structure_stochastic_block_models_files/chapter_31_latent_network_structure_stochastic_block_models_94_0.pdf" class="img-fluid"></p>
<figcaption class="figure-caption">png</figcaption>
</figure>
</div>
<pre><code>(&lt;VertexPropertyMap object with value type 'vector&lt;double&gt;', for Graph 0x7f74c8ac3670, at 0x7f74c43f4a00&gt;,
 &lt;Graph object, directed, with 172 vertices and 171 edges, at 0x7f74c433b9d0&gt;,
 &lt;VertexPropertyMap object with value type 'vector&lt;double&gt;', for Graph 0x7f74c433b9d0, at 0x7f74c431ea90&gt;)</code></pre>
<p>As is often the case, there are a few preparation steps we can do to improve the visualization of edges, as well as to add node labels to our figure. This process is a bit complex and is an adaptation of one that was devised by the author of graph-tool. The details aren’t particularly important, so we can use the utility function <code>label_radial_blockmodel</code> from the dcss package to take care of most of it.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>eG <span class="op">=</span> label_radial_blockmodel(eG, state)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The resulting figure is much improved (Figure <span class="quarto-unresolved-ref">?fig-31_04</span>), and clearly shows the relations between blocks, while also making it easier to examine which job titles were assigned to each block.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>state.draw(</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    vertex_text <span class="op">=</span> eG.vertex_properties[<span class="st">'title'</span>], </span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    eorder <span class="op">=</span> eG.edge_properties[<span class="st">'edge_weight'</span>],</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    vertex_shape<span class="op">=</span><span class="st">'pie'</span>,</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    vertex_pie_fractions<span class="op">=</span>eG.vertex_properties[<span class="st">'pv'</span>],</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    edge_control_points <span class="op">=</span> eG.edge_properties[<span class="st">'cts'</span>],</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>    pos<span class="op">=</span>eG.vertex_properties[<span class="st">'pos'</span>], </span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>    vertex_size<span class="op">=</span><span class="dv">10</span>, </span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    edge_pen_width <span class="op">=</span> <span class="fl">0.2</span>,</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">1</span>],</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>    vertex_text_rotation<span class="op">=</span>eG.vertex_properties[<span class="st">'text_rot'</span>],</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    vertex_text_position<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    output<span class="op">=</span><span class="st">'figures/core_state_radial_tree_labels.pdf'</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>(&lt;VertexPropertyMap object with value type 'vector&lt;double&gt;', for Graph 0x7f74c8ac3670, at 0x7f7550a574f0&gt;,
 &lt;Graph object, directed, with 172 vertices and 171 edges, at 0x7f7550a4d700&gt;,
 &lt;VertexPropertyMap object with value type 'vector&lt;double&gt;', for Graph 0x7f7550a4d700, at 0x7f7550a55970&gt;)</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="figures/core_state_radial_tree_labels1.pdf" class="img-fluid"></p>
<figcaption class="figure-caption">Cap</figcaption>
</figure>
</div>
<p>You’ll notice that some of the nodes are broken up into pie fractions - these indicate their probability of being assigned to a different block. In the full colour version, these fractions are coloured the same as the alternative block that the node might have been assigned to. You’ll also notice that the blocks have become significantly more heterogenous! Traders are in blocks with other traders, most lawyers are in a block that two other lawyers had some probability of being assigned to, and the CEOs are in fairly exclusive blocks. Although we no longer have 3 CEOs in one block with the COO, the block that one of the CEOs was moved to contains the other CEO, and their two respective blocks form a single block one level up the hierarchy! Earlier I mentioned that there are possible explanations for a decreased adjusted mutual information score and this is one example - that score doesn’t incorporate the higher levels of the hierarchy. Even though it’s probably actually a better model to have the four CEOs split evenly among two blocks, then put those two blocks together at the next hierarchy level, this would still negatively impact the mutual info score compared to the model where 3 CEOs were in one block.</p>
<p>It’s quite clear from the results of these stochastic blockmodels that there’s some very powerful estimation going on, and that the Bayesian aspects of it allow a great deal of nuance. The versatility of the modeling that drives graph-tool has led to a collaborative extension for topic modeling. Given the relational nature of words in text, which is often analyzed in the same way as social relations, topics can be blockmodelled from text documents to great effect. We’ll explore this method in the section that follows.</p>
</section>
<section id="topsbm-a-unified-bayesian-approach-to-latent-variable-modelling-for-text-and-networks" class="level3" data-number="16.4.9">
<h3 data-number="16.4.9" class="anchored" data-anchor-id="topsbm-a-unified-bayesian-approach-to-latent-variable-modelling-for-text-and-networks"><span class="header-section-number">16.4.9</span> TopSBM: A Unified Bayesian Approach to Latent Variable Modelling for Text and Networks</h3>
<p>At the start of this chapter, I noted that there is a deep underlying similarity between SBMs and LDA. Both are Hierachical Bayesian models developed to overcome the limitations of widely-used deterministic methods. However, <span class="citation" data-cites="gerlach2018network">Gerlach, Peixoto, and Altmann (<a href="references.html#ref-gerlach2018network" role="doc-biblioref">2018</a>)</span> have generalized SBMs to text data as an alternative to LDA, and in doing so have addressed some of the limitations inherent in the baseline LDA models. Specifically, TopSBM, as the generalization is known, makes use of the full set of additional inferential techniques described above that enable TopSBM to:</p>
<ul>
<li>explore a broader variety of topic mixtures by avoiding the use of a Dirichlet prior;</li>
<li>removes the need to select a number of topics in advance due to the specific hierarchical design of the model, and the use of hyperpriors;</li>
<li>uses efficient MCMC posterior inference rather than variational inference, which means that the model can handle large-scale data without relying on an optimization strategy.</li>
</ul>
<p>The TopSBM approach models text datasets as a <strong>bipartite network</strong>, which is a network that has two types of nodes, and where connections are only allowed across types. In this case, the two types of nodes are words and documents, where we assign an edge between words and documents if a word appears in a document, but we do <em>not</em> assign edges from word to word, or document to document.</p>
<p>One of the deep conceptual similarities here is that the matrix form of a bipartite network is analogous to a document-term feature matrix, and when the nodes in the bipartite network are words and documents, <em>the matrices are identical</em>. The identical underlying data structures and the conceptual similarity of the goals of recovering latent topics in text data and latent structure in network data allows us to easily develop SBM models for text data. In doing so, we benefit from the additional inferential techniques that have been developed for SBMs.</p>
<p>A full discussion of TopSBM is beyond the score of this chapter, and sadly so is developing a model, but this will be available in the supplementary online material. However, I strongly encourage you to put your developing skills to use here and try your hand at developing one! Meanwhile, if you want to learn more about the theory and mathematics behind TopSBM, or better understand the relationship between topic modeling and community detection and blockmodelling, I recommend reading <span class="citation" data-cites="gerlach2018network">Gerlach, Peixoto, and Altmann (<a href="references.html#ref-gerlach2018network" role="doc-biblioref">2018</a>)</span>. If you just want to take a look at some results, there is a pickle available in the <code>data/pickles</code> directory, and a few example topics in a dataframe below. This model was run on a 100K random sample of the Canadian Hansards and took quite a long time to complete.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>topSBM_model <span class="op">=</span> pickle.load( <span class="bu">open</span>( <span class="st">'data/can_hansard_100k_sample_topSBM.pkl'</span>, <span class="st">'rb'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>topic_dict <span class="op">=</span> topSBM_model.topics(l<span class="op">=</span><span class="dv">1</span>,n<span class="op">=</span><span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>df_list <span class="op">=</span> []</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> topic <span class="kw">in</span> [<span class="dv">76</span>,<span class="dv">91</span>,<span class="dv">200</span>,<span class="dv">228</span>,<span class="dv">104</span>,<span class="dv">126</span>]:</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame.from_records(topic_dict[topic], columns <span class="op">=</span> [<span class="st">'words_'</span> <span class="op">+</span> <span class="bu">str</span>(topic), <span class="st">'scores_'</span> <span class="op">+</span> <span class="bu">str</span>(topic)])</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    df_list.append(df)</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>topic_df <span class="op">=</span> pd.concat(df_list, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>topic_df.head(<span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>       words_76  scores_76    words_91  scores_91       words_200  scores_200  \
0           gas   0.184736      regime   0.206437  infrastructure    0.259398   
1       climate   0.141000   violation   0.109540    municipality    0.131606   
2        carbon   0.101561        Iran   0.064138            road    0.109510   
3      emission   0.088723     torture   0.049770        building    0.093287   
4         clean   0.075559     protest   0.032759       municipal    0.077184   
5    greenhouse   0.069086     iranian   0.029655    construction    0.059265   
6          fuel   0.065223        Cuba   0.026782         transit    0.058902   
7     pollution   0.048523    activist   0.023678           mayor    0.042920   
8         green   0.046075      brutal   0.019885             bus    0.026273   
9       ethanol   0.013056       Egypt   0.018966          design    0.018221   
10      heating   0.012566    dictator   0.017126          stream    0.013742   
11      warming   0.012185  systematic   0.015632      councillor    0.011926   
12       fossil   0.012131   Venezuela   0.014253  Municipalities    0.011320   
13  temperature   0.011913       Khadr   0.013448           sewer    0.008112   
14      Climate   0.009846   execution   0.012644           Mayor    0.007022   
15     polluter   0.009248     embargo   0.011494            pass    0.006659   
16       Change   0.009084        Omar   0.011034         upgrade    0.004903   
17    pollutant   0.006582     Amnesty   0.010920          shovel    0.004480   
18      dioxide   0.006473       Burma   0.010575          subway    0.003753   
19       diesel   0.006093     Myanmar   0.009195            Road    0.003753   

       words_228  scores_228      words_104  scores_104       words_126  \
0      emergency    0.360683         social    0.351863         society   
1        vaccine    0.064984        poverty    0.166007       principle   
2          virus    0.054231           poor    0.128998           value   
3       outbreak    0.047920           rich    0.067926     institution   
4           SARS    0.046517         living    0.055031     fundamental   
5       pandemic    0.040673        welfare    0.051680           basic   
6         spread    0.040673         wealth    0.038989           equal   
7       epidemic    0.039037         decent    0.020104           voice   
8   preparedness    0.031791     inequality    0.016753         concept   
9          Ebola    0.030856  disadvantaged    0.016347        powerful   
10          dose    0.023142           load    0.012793           ideal   
11          H1N1    0.022207         hungry    0.008529  characteristic   
12           flu    0.021272      disparity    0.007869            like   
13     influenza    0.020570          needy    0.006650     cornerstone   
14    quarantine    0.020103         steady    0.005584           noble   
15    infectious    0.018700        kitchen    0.005026       Coalition   
16           kit    0.014960            pie    0.005026   institutional   
17          mask    0.014493         clothe    0.005026   philosophical   
18   containment    0.013558           tory    0.004366       motivated   
19         avian    0.012856           soup    0.002741        hallmark   

    scores_126  
0     0.191839  
1     0.164089  
2     0.145013  
3     0.115906  
4     0.085317  
5     0.066920  
6     0.052844  
7     0.048091  
8     0.043677  
9     0.016174  
10    0.008890  
11    0.008581  
12    0.007964  
13    0.007007  
14    0.005772  
15    0.005062  
16    0.004784  
17    0.003519  
18    0.002469  
19    0.002346  </code></pre>
<p>As you can see, these topics end up being pretty coherent! There were 267 topics found from this run and the majority of them are intuitive enough that they seem a bit obvious. This is a good thing.</p>
</section>
</section>
<section id="conclusion" class="level2" data-number="16.5">
<h2 data-number="16.5" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">16.5</span> CONCLUSION</h2>
<section id="key-points" class="level3" data-number="16.5.1">
<h3 data-number="16.5.1" class="anchored" data-anchor-id="key-points"><span class="header-section-number">16.5.1</span> Key Points</h3>
<ul>
<li>Hierarchical Stochastic Blockmodels are remarkably powerful models that provide a nearly unparalleled degree of insight into the structure of a network and nodes’ roles within it</li>
<li>SBMs build on the Bayesian intuitions established earlier in this book; they employ a similar approach of using latent variables and prior distributions to model unknown/unobserved</li>
<li>TopSBM is really cool. Once you’re comfortable with the material in this chapter and the previous one, you should explore TopSBM on your own, or using the supplementary material online.</li>
</ul>
</section>
</section>
</section>
<section id="connection-and-clustering-in-social-networks" class="level1" data-number="17">
<h1 data-number="17"><span class="header-section-number">17</span> Connection and Clustering in Social Networks</h1>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Planned Updates
</div>
</div>
<div class="callout-body-container callout-body">
<p>The chapters on network analysis are being actively revised in fall 2024. The primary change is that they will now be presented from a more fully-developed generative perspective.</p>
<p>The sections on detecting cohesive subgroups in networks will change the most. They will include strong criticism of Louvain and Leiden (modularity maximization approaches in general). The sections on <span class="math inline">\(k\)</span>-clique communities, <span class="math inline">\(k\)</span>-components and structural cohesion analysis, and <span class="math inline">\(k\)</span>-core decomposition will be removed. I will introduce positional analysis and blockmodels, including a first stochastic blockmodel. I will set aside larger questions of inference with SBMs until later in the book.</p>
</div>
</div>
<section id="learning-objectives" class="level2" data-number="17.1">
<h2 data-number="17.1" class="anchored" data-anchor-id="learning-objectives"><span class="header-section-number">17.1</span> LEARNING OBJECTIVES</h2>
<ul>
<li>Compare different microstructural configurations at the level of dyads and triads</li>
<li>Learn how to conduct a triad census</li>
<li>Detect subgroups in social networks using:
<ul>
<li><span class="math inline">\(k\)</span>-clique communities</li>
<li>Louvain community detection</li>
<li>Leiden community detection</li>
<li><span class="math inline">\(k\)</span>-components and structural cohesion analysis</li>
<li><span class="math inline">\(k\)</span>-core decomposition</li>
</ul></li>
</ul>
</section>
<section id="learning-materials-1" class="level2" data-number="17.2">
<h2 data-number="17.2" class="anchored" data-anchor-id="learning-materials-1"><span class="header-section-number">17.2</span> LEARNING MATERIALS</h2>
<p>You can find the online learning materials for this chapter in <code>doing_computational_social_science/Chapter_15</code>. <code>cd</code> into the directory and launch your Jupyter Server.</p>
</section>
<section id="introduction-1" class="level2" data-number="17.3">
<h2 data-number="17.3" class="anchored" data-anchor-id="introduction-1"><span class="header-section-number">17.3</span> INTRODUCTION</h2>
<p>This chapter expands on the general introduction to social networks in the previous chapter by widening our discussion to micro- and meso-level structures in social networks. We begin with the building blocks of network structure: dyads. Dyads provide the basis for discussing triads, which are in turn the basis for the more complex meso-level structures we discuss afterwards: cohesive subgroups and communities. There are many ways of detecting cohesive subgroups in networks, some of which start with micro-level structural configurations that overlap to form larger and more complex structures, and others that start at the level of the network itself and work their way down to smaller structures. We will start with two common “bottom-up” approaches, (1) <span class="math inline">\(k\)</span>-clique communities and (2) Louvain and Leiden community detection, followed by two “top-down” approaches to describing network structure, (3) <span class="math inline">\(k\)</span>-component structural cohesion analysis and (4) <span class="math inline">\(k\)</span>-core decomposition. While these ideas are not unique to “computational” approaches to network analysis, computational network analysis rests on top of these more general foundations, so they are essential to understand first.</p>
<section id="imports-1" class="level3" data-number="17.3.1">
<h3 data-number="17.3.1" class="anchored" data-anchor-id="imports-1"><span class="header-section-number">17.3.1</span> Imports</h3>
<div class="sourceCode" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics.pairwise <span class="im">import</span> euclidean_distances</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.cluster <span class="im">import</span> hierarchy</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> networkx.algorithms.community <span class="im">import</span> k_clique_communities</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> networkx.algorithms.triads <span class="im">import</span> triadic_census</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> community</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dcss <span class="im">import</span> set_style</span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>set_style()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="data-1" class="level3" data-number="17.3.2">
<h3 data-number="17.3.2" class="anchored" data-anchor-id="data-1"><span class="header-section-number">17.3.2</span> Data</h3>
<p>In this chapter, we’ll use both randomly generated networks and the 2013 data on reported contacts collected from the high school students in Marseilles. Technically this is a directed network, but some of the methods we will cover in this chapter are not implemented for directed networks. Instead, we will treat it as an <em>undirected</em> network.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>contact_diaries <span class="op">=</span> pd.read_csv(<span class="st">"data/SocioPatterns/Contact-diaries-network_data_2013.csv"</span>, sep<span class="op">=</span><span class="st">' '</span>)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.from_pandas_edgelist(contact_diaries, <span class="st">'i'</span>, <span class="st">'j'</span>, create_using<span class="op">=</span>nx.Graph())</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>G.name <span class="op">=</span> <span class="st">'Reported Contacts (Diary Data)'</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(G)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>contact_diaries.j.unique()[:<span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="micro-level-network-structure-and-processes" class="level2" data-number="17.4">
<h2 data-number="17.4" class="anchored" data-anchor-id="micro-level-network-structure-and-processes"><span class="header-section-number">17.4</span> MICRO-LEVEL NETWORK STRUCTURE AND PROCESSES</h2>
<p>The smallest <em>relational</em> units in a network are <strong>dyads</strong> (2 nodes) and <strong>triads</strong> (3 nodes). Much of network analysis rests on aggregations of these simple structures into more complex configurations, so it is important to understand the vocabulary that network analysts use to describe the different forms that dyads and triads take. Let’s start with dyads.</p>
<section id="dyads-and-reciprocity" class="level3" data-number="17.4.1">
<h3 data-number="17.4.1" class="anchored" data-anchor-id="dyads-and-reciprocity"><span class="header-section-number">17.4.1</span> Dyads and Reciprocity</h3>
<p>A dyad consists of the presence or absence of an edge between two nodes, the minimum number of nodes and edges that can define a relation. I say “presence or absence” because <em>absence matters</em>. Edges that do not exist are as informative as edges that do exist (the case of missing data leads to a very interesting literature including covert and illicit networks that is beyond our present scope). Whole networks are built up from the presence and absence of edges between every pair of nodes in the network.</p>
<p>If our network is directed, it is possible to observe dyads that differ from those in undirected networks. In Figure <a href="13-social-networks-and-relational-thinking.html#fig-15_01">Figure&nbsp;<span>13.1</span></a>, for example, we have two nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>. There are three possible configurations of nodes and the relationships between them: <strong>mutual</strong> (<span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> both send edges to one another, <span class="math inline">\(i \longleftrightarrow j\)</span>, which is an indication of reciprocity), <strong>asymmetric</strong> (one sends an unreciprocated edge to the other, either <span class="math inline">\(i \rightarrow j\)</span> or <span class="math inline">\(j \leftarrow i\)</span>), and <strong>null</strong> (the absence of an edge between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>). The possibilities are summarized in the figure below. For obvious reasons, we refer to this as the MAN framework; <strong>m</strong>utual, <strong>a</strong>symmetric, <strong>n</strong>ull.</p>
<p><embed src="figures/dyads.pdf" class="img-fluid"></p>
<p>In directed social networks, we may or may not expect to see <strong>reciprocity</strong>. This is one of many structural forms that we hypothesize about, <em>look for</em>, and model. For example, in interaction networks amoung friends, we should expect to see that when one friend sends another friend a message, <em>they respond</em>. However, in an advice giving network, we might expect to see more asymmetry; graduate students turn to their supervisors for career advice more often then supervisors turn to graduate students for advice. The key takeaway here is that there is a social process, <em>reciprocity</em>, that is reflected in the edges of directed networks. The social process <em>generates</em> the structural form. Other types of social processes manifest in other types of structural forms, and this is one reason why network analysis is a powerful tool for thinking systemically about our interdependencies with one another.</p>
<p>Dyads are foundational to social network analysis, though they tend to get less attention because they cannot by themselves speak to higher-order concepts such as community structure or network positions. In order to get at those ideas, we need to introduce another level of complexity.</p>
</section>
<section id="triads-and-triadic-closure" class="level3" data-number="17.4.2">
<h3 data-number="17.4.2" class="anchored" data-anchor-id="triads-and-triadic-closure"><span class="header-section-number">17.4.2</span> Triads and Triadic Closure</h3>
<p>The next micro-level structure is the <strong>triad</strong>, just one level up from the dyad. As the name would suggest, triads are the extension of dyads to three ordered nodes. Triads have an especially important place in network analysis, and theoretical work on their importance can be traced back to the classic works of the German sociologist Georg Simmel in 1901. Simmel observed that the addition of a third person to a triad has <em>far</em> more dramatic effects than adding a fourth person to a triad, or any other additions that increase the size of the group. The transition from 2 people to 3 people is a substantial qualitative change in the relationship and entirely changes what is possible <span class="citation" data-cites="wolff1950sociology">(see excerpts in <a href="references.html#ref-wolff1950sociology" role="doc-biblioref">Wolff 1950</a>)</span>. One of Simmel’s examples, that is by no means the most insightful but which drives the point home, is the difference between couples with and without a child. The difference between couples who have a child and those who are child-free is much bigger than the difference between a couple with one child and a couple with two. More generally, the introduction of a third person means that two people can ally themselves to pressure the third, and so on.</p>
<p>Because triads allow relations between two nodes to be understood within the context of a third person, and because of all the qualitative relational differences that the introduction of a third person poses, we can think of triads as the smallest structural elements of larger groups, communities, and societies. For example, when a dyad disagrees, there is no recourse to outside influence, be it mediators, tie-breaking votes, or the like. When a dyad disagrees within a triad, the third node has the opportunity to influence or be influenced by it.</p>
</section>
<section id="man-for-triads" class="level3" data-number="17.4.3">
<h3 data-number="17.4.3" class="anchored" data-anchor-id="man-for-triads"><span class="header-section-number">17.4.3</span> MAN for Triads</h3>
<p>Earlier, we introduced the MAN framework for differentiating between different types of dyads in a directed network: mutual, asymmetric, and null. The possibilities are fewer for an undirected network: present or absent. With an undirected network the possibilities for triads are also fairly straightforward. We can observe triads with no edges between the nodes, with one edge, with two edges, or with three edges.</p>
<p>Things become considerably more complex for directed networks. Whereas a dyad in a directed network has 3 possible configurations, a triad in a directed network has 16 possible configurations, and differentiating between them requires some specialized vocabulary. We’ll use a framework proposed by <span class="citation" data-cites="davis1967structure">Davis and Leinhardt (<a href="references.html#ref-davis1967structure" role="doc-biblioref">1967</a>)</span> to describe every possible configuration of a triad with directed edges. This framework rests on the MAN framework for dyads, also introduced by <span class="citation" data-cites="davis1967structure">Davis and Leinhardt (<a href="references.html#ref-davis1967structure" role="doc-biblioref">1967</a>)</span>.</p>
<p>The description of a triad under the MAN framework takes the form of a three digit number, where each digit represents the number of mutual, asymmetric, and null relations within the triad. Thus, the triad described by 003 would be a triad with 0 mutual relations, 0 asymmetric relations, and 3 null relations. In short, it’s a graph of 3 nodes with no edges. 300 describes a triad where each node has a mutual relation with the others. In other words, there are 3 dyads embedded in this triad. If we name the nodes <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span>, we have <span class="math inline">\(A \longleftrightarrow B\)</span>, <span class="math inline">\(A \longleftrightarrow C\)</span>, and <span class="math inline">\(B \longleftrightarrow C\)</span>.</p>
<p>Since the MAN relations describe all possible edge configurations within a dyad, the sum of the three digits in a MAN triad will always be 3. That gives us the following possible configurations: <code>300</code>, <code>210</code>, <code>201</code>, <code>120</code>, <code>102</code>, <code>111</code>, <code>030</code>, <code>021</code>, <code>012</code>, and <code>003</code>.</p>
<p>That might seem like a lot, but it describes only 10 of the 16 possible configurations for triads in a directed network. Consider the case of 030, the triad where each dyad has a single directed edge between them. This configuration might be <strong>cyclical</strong> or it might be <strong>transitive</strong>. A cyclical triad is simply a cycle (discussed in the previous chapter) made with three nodes. A transitive triad takes the form <span class="math inline">\(A \rightarrow B\)</span>, <span class="math inline">\(B \rightarrow C\)</span>, and <span class="math inline">\(A \rightarrow C\)</span>. One node sends two edges. One node sends an edge and receives an edge. The last node receives two edges.</p>
<p>These two subconfigurations are given a capital letter to differentiate them, giving us 030C and 030T, respectively. The full set of 16 configurations is shown in Figure <a href="13-social-networks-and-relational-thinking.html#fig-15_02">Figure&nbsp;<span>13.2</span></a>.</p>
<p><embed src="figures/census.pdf" class="img-fluid"></p>
<p>We can count the number of every one of these 16 configurations in a directed network by conducting a <strong>triad census</strong>. This gives us some insight into the kinds of micro-level structures that are more or less prevalent in the network we are analyzing. This requires examining <em>every combination of 3 nodes</em> in the network to identify which MAN triad they belong to. The number of such combinations in a network of any moderate size quickly becomes infeasible to conduct by hand, so we turn to computer algorithms.</p>
<p>To build a bit of intuition about the complexities involved here, and their implications for other network methods, we’ll use a custom dcss function to simulate a network, execute a triad census, modify it a bit, and then conduct another census. Let’s simulate a random network with 50 nodes using the <code>gn_graph()</code>, function, which creates a growing network (GN) with directed edges.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> networkx.algorithms.triads <span class="im">import</span> triadic_census</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>gn_50 <span class="op">=</span> nx.gn_graph(<span class="dv">50</span>, seed <span class="op">=</span> <span class="dv">42</span>)</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>sim_50 <span class="op">=</span> pd.Series(triadic_census(gn_50))</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>sim_50</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>While we might notice certain configurations are more prevalent than others, it’s important to remember that interpreting and comparing these counts is not so straightforward. Two triads may overlap. The mutual relationship between the dyad of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> will show up in the <span class="math inline">\(ABC\)</span> triad, but also the <span class="math inline">\(ABD\)</span> triad, and the <span class="math inline">\(ABE\)</span> triad, and so on. A triad census will <em>necessarily</em> count every dyad multiple times, and every triad will have multiple overlaps with others. Consider another issue. Network <strong>density</strong> is the proportion of <em>potential</em> connections in a network that are realized. As network density decreases, we would certainly expect to see a greater number of triads with more null relationships.</p>
<p>Let’s generate a new network with only 20 nodes. We will define another function that prints the number of nodes, edges, and network density. Finally, we will create a simple visualization of this network (Figure <a href="#fig-14_03">Figure&nbsp;<span>17.1</span></a>).</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>gn <span class="op">=</span> nx.gn_graph(<span class="dv">20</span>, seed <span class="op">=</span> <span class="dv">42</span>)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>gn.name <span class="op">=</span> <span class="st">"Simulated DiGraph with 20 Nodes"</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> describe_simulated_network(network):</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Network: </span><span class="sc">{</span>network<span class="sc">.</span>name<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Number of nodes: </span><span class="sc">{</span>network<span class="sc">.</span>number_of_nodes()<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Number of edges: </span><span class="sc">{</span>network<span class="sc">.</span>number_of_edges()<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'Density: </span><span class="sc">{</span>nx<span class="sc">.</span>density(network)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>describe_simulated_network(gn)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>layout <span class="op">=</span> nx.fruchterman_reingold_layout(gn, seed<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>nx.draw(gn, layout, node_color<span class="op">=</span><span class="st">'darkgray'</span>,</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>        edge_color<span class="op">=</span><span class="st">'gray'</span>, node_size<span class="op">=</span><span class="dv">100</span>, width<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_03.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_03" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_03.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.1: png</figcaption>
</figure>
</div>
<p>Now let’s conduct a triad census on the network.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>sim_20_a <span class="op">=</span> pd.Series(triadic_census(gn))</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>sim_20_a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, let’s add a single node <em>with no edges</em> and see how it affects our triad census.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>gn.add_node(<span class="st">"an isolate"</span>)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>describe_simulated_network(gn)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ve added just a single new node with no edges, an “<strong>isolate</strong>”. The number of edges in the network is the same, and the difference in the density is minor. But what happens when we run the triad census again?</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>sim_20_b <span class="op">=</span> pd.Series(triadic_census(gn))</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>sim_20_b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can simplify the comparison by making it visual. Below we’ll plot the counts for each of the triadic configurations for both networks. The values for the original network are shown in Figure <a href="#fig-14_04">Figure&nbsp;<span>17.2</span></a> with grey points. The values for same simulation with a single isolate added are shown with crimson plus marks.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>sim_20_a,</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>                y<span class="op">=</span>sim_20_a.index,</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>                s<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">.8</span>,</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">"Simulated network"</span>)</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>sim_20_b,</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>                y<span class="op">=</span>sim_20_b.index,</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>                color<span class="op">=</span><span class="st">'crimson'</span>,</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>                marker<span class="op">=</span><span class="st">"+"</span>,</span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>                s<span class="op">=</span><span class="dv">80</span>,</span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">"Simulated network + one isolate"</span>)</span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'Count'</span>, ylabel<span class="op">=</span><span class="st">'Triad configurations'</span>)</span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>sns.despine()</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_04.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_04" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_04.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.2: png</figcaption>
</figure>
</div>
<p>We’ve added quite a few new 003 triads (171 to be precise) and a non-trivial number of 012 triads (19). All this despite the fact that there has been no appreciable change in the structure of the network.</p>
<p>Finally, let’s consider two networks with the same number of nodes and edges. One network will contain a very dense group, while the other will not.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>clustered_g <span class="op">=</span> nx.null_graph(create_using<span class="op">=</span>nx.DiGraph())</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>nodes <span class="op">=</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">20</span>)</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>    clustered_g.add_node(<span class="bu">str</span>(node))</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">9</span>):</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">9</span>):</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">!=</span> j:</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>            clustered_g.add_edge(<span class="bu">str</span>(i), <span class="bu">str</span>(j))</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>clustered_g.name <span class="op">=</span> <span class="st">'Simulated DiGraph, Clustered'</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>describe_simulated_network(clustered_g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>not_clustered_g <span class="op">=</span> nx.null_graph(create_using<span class="op">=</span>nx.DiGraph())</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> nodes:</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>    not_clustered_g.add_node(<span class="bu">str</span>(node))</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">72</span>):</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>    random_from <span class="op">=</span> <span class="bu">str</span>(random.randint(<span class="dv">0</span>,<span class="dv">19</span>))</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>    random_to <span class="op">=</span> <span class="bu">str</span>(random.randint(<span class="dv">0</span>,<span class="dv">19</span>))</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> not_clustered_g.has_edge(random_from, random_to):</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>        random_from <span class="op">=</span> <span class="bu">str</span>(random.randint(<span class="dv">0</span>,<span class="dv">19</span>))</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>        random_to <span class="op">=</span> <span class="bu">str</span>(random.randint(<span class="dv">0</span>,<span class="dv">19</span>))</span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>    not_clustered_g.add_edge(random_from, random_to)</span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>not_clustered_g.name <span class="op">=</span> <span class="st">'Simulated DiGraph, Not Clustered'</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a>describe_simulated_network(not_clustered_g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now let’s compute a census for both simulated networks and then compare the results visually (Figure <a href="#fig-14_05">Figure&nbsp;<span>17.3</span></a>).</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>tc_clustered <span class="op">=</span> pd.Series(triadic_census(clustered_g))</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>tc_not_clustered <span class="op">=</span> pd.Series(triadic_census(not_clustered_g))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>tc_clustered,</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>                y<span class="op">=</span>tc_clustered.index,</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>                s<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>                alpha<span class="op">=</span><span class="fl">.8</span>,</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">"Simulated network, clustered"</span>)</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>tc_not_clustered,</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>                y<span class="op">=</span>tc_not_clustered.index,</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>                color<span class="op">=</span><span class="st">'crimson'</span>,</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>                marker<span class="op">=</span><span class="st">"+"</span>,</span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>                s<span class="op">=</span><span class="dv">80</span>,</span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">"Simulated network, not clustered"</span>)</span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'Count'</span>, ylabel<span class="op">=</span><span class="st">'Triad configurations'</span>)</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>sns.despine()</span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_05.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_05" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_05.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.3: png</figcaption>
</figure>
</div>
<p>Remember, these two networks have the same number of nodes and edges, but one has a dense cluster and the other does not. What has happened is that the dense cluster has a monopoly on the edges, there is a large number of heavily overlapping <code>300</code> triads, a much greater number of <code>003</code> null triads created by there being more isolates, and there are many more <code>102</code> triads representing two isolates and a member of the dense cluster.</p>
<p>The key point to take away from these simple simulations is that raw counts of micro-structural configurations in a network, for example via a triad census, can be deceiving. They are nested and complex. However, a triad census can be part of an initial exploratory analysis if you are being careful <em>and intentional</em>. Among other things, they may help you think through what types of processes and mechanisms might be contributing to the specific structural forms a network takes.</p>
<p>Consider a network of journal articles that cite other journal articles. If we perform a triad census on a citation network, we should absolutely expect to see many more 030T triads than 030C triads. In fact, <em>we might see no 030C triads at all</em>, as such a triad suggests that a paper <span class="math inline">\(A\)</span> cited a paper <span class="math inline">\(B\)</span>, that cited a paper <span class="math inline">\(C\)</span>, that cited the original paper <span class="math inline">\(A\)</span>. Given that most articles cite papers that have already been published, rather than papers that have yet to be published, such triads should be exceedingly rare, though technically not impossible.</p>
</section>
</section>
<section id="detecting-cohesive-subgroups-and-assortative-structure" class="level2" data-number="17.5">
<h2 data-number="17.5" class="anchored" data-anchor-id="detecting-cohesive-subgroups-and-assortative-structure"><span class="header-section-number">17.5</span> DETECTING COHESIVE SUBGROUPS AND ASSORTATIVE STRUCTURE</h2>
<p>There are many ways of detecting <strong>cohesive subgroups</strong>, often called <strong>communities</strong>, in social networks. Some methods start with micro-level structural configurations that overlap to form larger and more complex structures, while others start at the level of the network itself and work their way down to smaller structures. In the subsections that follow, we will explore a variety of methods for such techniques.</p>
<p>We will start with the <span class="math inline">\(k\)</span>-clique communities approach, which starts by identifying small groups of densely connected nodes (<span class="math inline">\(k\)</span>-cliques) and builds up to larger communities by combining adjacent groups of densely connected nodes. This approach is designed to allow nodes to belong to more than one community, as is the case in real life. We will then discuss Louvain and Leiden community detection, both of which partition networks into mutually-exclusive communities where nodes have more connections internally to one another than they do externally to other regions of the network.</p>
<p>The final approach we will cover – <span class="math inline">\(k\)</span>-core analysis – identifies the most connected nodes in a component, revealing a component’s ‘core.’ Other methods, like structural cohesion analysis, reveal the core of a component by progressively disconnecting components at their weakest points. Like <span class="math inline">\(k\)</span>-clique communities, the <span class="math inline">\(k\)</span>-core approach allows nodes to be part of multiple cohesive subgroups, but this means something a little different than what is meant by the <span class="math inline">\(k\)</span>-clique communities approach. Here, cohesive subgroups are hierarchically nested, so one can be part of multiple cohesive subgroups in the sense that some subgroups are nested inside other, larger, subgroups.</p>
<p>Let’s work our way through each of these approaches.</p>
<section id="cliques-and-k-clique-communities" class="level3" data-number="17.5.1">
<h3 data-number="17.5.1" class="anchored" data-anchor-id="cliques-and-k-clique-communities"><span class="header-section-number">17.5.1</span> Cliques and <span class="math inline">\(k\)</span>-Clique Communities</h3>
<p>You are probably familiar with the idea of a clique from everyday. In network analysis, we use the term a little differently: a “<strong>clique</strong>” is a set of nodes that is <em>completely</em> connected, meaning that every node is connected to every other node in the clique. As this is the only requirement, cliques can vary in sizes. However, they tend not to be especially large, since most real social networks are fairly sparse, and <em>complete</em> connection is an extremely high bar.</p>
<p>The <span class="math inline">\(k\)</span>-clique is a variation on this idea, where <span class="math inline">\(k\)</span> is the number of nodes in the clique. For example, if <span class="math inline">\(k = 5\)</span>, we want to find all groups of 5 nodes where each node in the set of 5 is connected to all other nodes. If 4 of the 5 nodes are completely connected but the fifth node is missing a connection to one of the other nodes, it is <em>not</em> a 5-clique, it’s a 4-clique.</p>
<p>The <span class="math inline">\(k\)</span>-clique communities approach to detecting cohesive subgroups is based on the idea that larger “community” structures in a network are built up from overlapping lower-level structures, such as triads and cliques. This basic idea – large overlapping communities composed of smaller overlapping structures – is an extremely appealing one because it better fits how we view social relations (e.g., as overlapping groups, or intersecting social circles) than alternative approaches that require nodes to be members of only one community (such as Louvain, which we will discuss shortly).</p>
<p>How do we know whether two cliques sufficiently overlap to be considered a ‘community?’ Following <span class="citation" data-cites="palla2005uncovering">Palla et al. (<a href="references.html#ref-palla2005uncovering" role="doc-biblioref">2005</a>)</span>, we can say that two <span class="math inline">\(k\)</span>-cliques overlap when they share at least <span class="math inline">\(k-1\)</span> nodes. In other words, if <span class="math inline">\(k = 4\)</span>, then two cliques that have 3 nodes in common (again, <span class="math inline">\(k-1\)</span>) are overlapping, or “adjacent.” Those two cliques are then merged into one community. This process continues until there are no more overlapping cliques.</p>
<p>Detecting cliques can be very computationally intensive, especially for large networks. Fortunately, there are variations on the basic idea that make it possible to do this type of analysis on larger and more complex graphs. The most common approach is the clique percolation method. In short, clique percolation works by:</p>
<ol type="1">
<li>Finding all the maximal cliques in a network.</li>
<li>Creating a <em>clique</em> adjacency matrix where the cells represent the number of nodes shared by two cliques.</li>
<li>Thresholding the matrix using the value <span class="math inline">\(k - 1\)</span> so as to prevent merging cliques that overlap but below the <span class="math inline">\(k - 1\)</span> threshold.</li>
<li>Forming communities from the connected components that remain after thresholding.</li>
</ol>
<p>This clique percolation method is implemented in <code>NetworkX</code> and is used when we run the <code>k_clique_communities()</code> function. We can select any value for <span class="math inline">\(k\)</span>, but remember that larger values will identify fewer cliques and fewer communities because large cliques are relatively rare in real world social networks and larger overlaps will be also be rare. Inversely, small values of <span class="math inline">\(k\)</span> will result in more cliques detected. The number of nodes required for communities to form from overlapping <span class="math inline">\(k\)</span>-cliques is also smaller, so communities will be more diffuse.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>ccs <span class="op">=</span> <span class="bu">list</span>(k_clique_communities(G, k))</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Identified </span><span class="sc">{</span><span class="bu">len</span>(ccs)<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">-clique communities.'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If we set <span class="math inline">\(k = 5\)</span>, as we do above, we find <span class="math inline">\(n\)</span> clique communities in the graph. We can print the node IDs for each of the communities by iterating over the lists produced by the code in the previous cell.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>communities <span class="op">=</span> [<span class="bu">list</span>(c) <span class="cf">for</span> c <span class="kw">in</span> ccs]</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> communities:</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(c)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Remember, the central idea here is that communities are <em>overlapping</em>, so we should see some nodes that appear in multiple communities. Let’s create a new dictionary where the keys are node IDs and the values are a list of the <span class="math inline">\(k\)</span>-clique communities that the node is embedded in. If a node is not part of any <span class="math inline">\(k\)</span>-clique communities, we will leave their list empty. We will just use numerical IDs (derived from the index in the outer list) for the community IDs.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>kccs <span class="op">=</span> {}</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node <span class="kw">in</span> G.nodes():</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    kcliques <span class="op">=</span> [communities.index(c) <span class="cf">for</span> c <span class="kw">in</span> communities <span class="cf">if</span> node <span class="kw">in</span> <span class="bu">list</span>(c)]</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    kccs[node] <span class="op">=</span> kcliques</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can print the list of overlapping nodes by simply checking for keys in the <code>dictionary</code> that have more than 1 <span class="math inline">\(k\)</span>-clique community. We will also create another list that includes the node IDs for all nodes that are embedded in <em>any</em> <span class="math inline">\(k\)</span>-clique component. This list can be used to determine the percentage of nodes in the network that are part of a community. We will also use it in a network visualization below.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>overlapping_nodes <span class="op">=</span> []</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>in_any_kclique <span class="op">=</span> []</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k, v <span class="kw">in</span> kccs.items():</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(v) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>        overlapping_nodes.append(k)</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(v) <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>        in_any_kclique.append(k)</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span><span class="bu">len</span>(overlapping_nodes)<span class="sc">}</span><span class="ss"> nodes belong to multiple $k$-clique communities: </span><span class="sc">{</span>overlapping_nodes<span class="sc">}</span><span class="ss">.'</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span><span class="bu">len</span>(in_any_kclique)<span class="sc">}</span><span class="ss"> nodes (</span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(<span class="bu">len</span>(in_any_kclique)<span class="op">/</span><span class="bu">len</span>(G), <span class="dv">2</span>)<span class="op">*</span><span class="dv">100</span><span class="sc">}</span><span class="ss">% of the network) are embedded in at least one $k$-clique community.'</span></span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Again, we can use some simple network visualizations to help interpret the results of our <span class="math inline">\(k\)</span>-clique analysis. This time, let’s construct a visualization where all nodes and edges are initially grey. Then we will overlay a visualization of the nodes that are embedded in at least one <span class="math inline">\(k\)</span>-clique component in crimson. Finally, we will print labels for nodes indicating the numerical ID of the community they are embedded in. The result is the network shown in Figure <a href="#fig-14_06">Figure&nbsp;<span>17.4</span></a>.</p>
<p>To do all of this, we need to do a little bit of prep work. Specifically, we need to get a list of tuples for the edges embedded in a <span class="math inline">\(k\)</span>-clique community and we need to create a dictionary of node labels: in this case, the numerical IDs for each detected community.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>layout <span class="op">=</span> nx.nx_pydot.graphviz_layout(G)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>edges_in_kcliques <span class="op">=</span> [</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    e <span class="cf">for</span> e <span class="kw">in</span> G.edges() <span class="cf">if</span> e[<span class="dv">0</span>] <span class="kw">in</span> in_any_kclique <span class="kw">and</span> e[<span class="dv">1</span>] <span class="kw">in</span> in_any_kclique</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>labs <span class="op">=</span> {}</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k, v <span class="kw">in</span> kccs.items():</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(v) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>        labs[k] <span class="op">=</span> v[<span class="dv">0</span>]</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>nx.draw(G,</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>        layout,</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>        node_color<span class="op">=</span><span class="st">'darkgray'</span>,</span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>        edge_color<span class="op">=</span><span class="st">'lightgray'</span>,</span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>        node_size<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a>        width<span class="op">=</span><span class="fl">.5</span>)</span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G,</span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>                       layout,</span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>                       node_color<span class="op">=</span><span class="st">'crimson'</span>,</span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>                       node_size<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>                       nodelist<span class="op">=</span>in_any_kclique)</span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G,</span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a>                       layout,</span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a>                       edge_color<span class="op">=</span><span class="st">'crimson'</span>,</span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a>                       edgelist<span class="op">=</span>edges_in_kcliques)</span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a>labs <span class="op">=</span> nx.draw_networkx_labels(G,</span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a>                               layout,</span>
<span id="cb116-27"><a href="#cb116-27" aria-hidden="true" tabindex="-1"></a>                               labels<span class="op">=</span>labs,</span>
<span id="cb116-28"><a href="#cb116-28" aria-hidden="true" tabindex="-1"></a>                               font_size<span class="op">=</span><span class="dv">6</span>,</span>
<span id="cb116-29"><a href="#cb116-29" aria-hidden="true" tabindex="-1"></a>                               font_color<span class="op">=</span><span class="st">'white'</span>)</span>
<span id="cb116-30"><a href="#cb116-30" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_06.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_06" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_06.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.4: png</figcaption>
</figure>
</div>
<p>In this particular network, the <span class="math inline">\(k\)</span>-clique community approach has identified a few communities that do indeed seem to be very cohesive and cliquish relative to other nodes in the network. It also seems like our aggregation rules for going from small cliques to larger communities is preventing the algorithm from identifying some small clusters of nodes in the network that probably should be considered “cohesive”.</p>
<p>Let’s flip the script a little and turn our attention to techniques that sort <em>everyone</em> in the network into one community or another. This solution may be a bit better, but the downside is that these approaches don’t allow overlap; everyone is a member of 1 and only 1 community.</p>
</section>
<section id="community-detection-using-louvain-and-leiden" class="level3" data-number="17.5.2">
<h3 data-number="17.5.2" class="anchored" data-anchor-id="community-detection-using-louvain-and-leiden"><span class="header-section-number">17.5.2</span> Community Detection using Louvain and Leiden</h3>
<p>Identifying cliques in a network is useful, but there are times when we want to know more about how group membership is spread across all of the nodes in a network. In these cases, we typically turn to a <strong>community detection algorithm</strong>. One of the most widely-used in recent years is the ‘Louvain’ community detection algorithm.</p>
<p>The Louvain community detection algorithm relies on a measure called <strong>modularity</strong> (<strong><span class="math inline">\(Q\)</span></strong>), which is a quantitative summary of how modular the structure of a given network is, and which is produced by analyzing the density of edges within a group relative to edges outside the group. The value of <span class="math inline">\(Q\)</span> ranges between a minimum of <span class="math inline">\(-\frac{1}{2}\)</span> and a maximum of 1. The more modular a network is (closer to 1), the more distinct “communities” it is composed of. In other words, networks with higher <span class="math inline">\(Q\)</span> are made up of communities that have many internal ties and relatively few external ties. To gloss over many details, the Louvain algorithm tries to optimize Q by checking how much moving a node into a community will increase Q, and moving it into the community that increases Q the most (if any move is positive). Once Q can’t be improved my moving nodes between communities, creates a new representation of the graph where each community is a node. It then repeats the process of trying to improve Q until there is only a single node.</p>
<p>In the modularity algorithm world, each algorithm varyingly provides some kind of modularity “guarantee.” For example, Louvain guarantees that when it is finished, no merging of communities can increase <span class="math inline">\(Q\)</span> further. If one iterates the algorithm, one can eventually guarantee that no nodes can be moved that would increase <span class="math inline">\(Q\)</span>. However, it makes no guarantee that this unimprovable partition is the <em>best</em> partition. It also doesn’t guarantee that moving a node to a different community will not disconnect an existing community. In short, this introduces a weakness, identified by <span class="citation" data-cites="traag2019louvain">Traag, Waltman, and Van Eck (<a href="references.html#ref-traag2019louvain" role="doc-biblioref">2019</a>)</span>, where a bridging node that holds two parts of a community together can be moved to another community. The result would be that the first community is now disconnected, in the sense that the only way to move from one part of it to the other is through a node that is now in an outside community. While this is particularly problematic, <span class="citation" data-cites="traag2019louvain">Traag, Waltman, and Van Eck (<a href="references.html#ref-traag2019louvain" role="doc-biblioref">2019</a>)</span> also point out that the less dramatic case of communities that are just poorly connected can be common. However, Louvain is very popular because it has outperformed many competing algorithms in producing better partitions and doing so faster.</p>
<p>The Louvain algorithm is implemented in the <code>best_partition()</code> method from the <code>community</code> package we imported earlier. Although the Louvain algorithm has been developed over time and is said to be adaptable to directed, weighted networks, the original implementation is for undirected binary networks and the python package doesn’t have the extensions implemented. We will talk about an alternative shortly that can make full use of the contact diary data.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>part <span class="op">=</span> community.best_partition(G)</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> community.modularity(part, G)</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The modularity of the network is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(q, <span class="dv">3</span>)<span class="sc">}</span><span class="ss">."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can use this community membership data in a variety of ways. The code below, for example, shows community membership differentiated by color. Figure <a href="#fig-14_07">Figure&nbsp;<span>17.5</span></a> is printed in grayscale, but you can find the full color version in the online supplementary learning materials.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [part[n] <span class="cf">for</span> n <span class="kw">in</span> G.nodes()]</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>my_colors <span class="op">=</span> plt.cm.Set2</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G,</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>                       pos<span class="op">=</span>layout,</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>                       node_size<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>                       node_color<span class="op">=</span>colors,</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>                       cmap<span class="op">=</span>my_colors)</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G, pos<span class="op">=</span>layout, edge_color<span class="op">=</span><span class="st">'lightgray'</span>, width<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_07.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_07" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_07.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.5: png</figcaption>
</figure>
</div>
<p>Louvain seems to have done a better job of identifying distinct clusters of densely connected nodes in this network than our <span class="math inline">\(k\)</span>-clique community approach. There are, however, limitations. While some of the communities seem well-defined (the one on the right is clear-cut), others get a little messy and appear to be overlapping; these may not be good partitions, but in this case it’s hard to tell because we have very limited information about the nodes, as this is an anonymized public dataset.</p>
<p>Sometimes it is useful to bump things up a level of analysis, such as by looking at networks of cohesive subgroups rather than networks of individuals who cluster into groups. Once you have detected communities with the Louvain algorithm, you can aggregate the communities into single nodes and assign edges between them when a node from one community has a tie to a node in another community. This can be done by simply passing the Louvain partitions and the network object to the <code>induced_graph()</code> function from the <code>community</code> package. Note that we will also collect data on edge weights to size the thickness of the edges in this induced network, similar to how we sized nodes based on their centrality in the previous chapter. The result is Figure <a href="#fig-14_08">Figure&nbsp;<span>17.6</span></a>.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>inet <span class="op">=</span> community.induced_graph(part, G)</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>inet.name <span class="op">=</span> <span class="st">"Induced Ego Network"</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [inet[u][v][<span class="st">'weight'</span>]  <span class="cf">for</span> u,v <span class="kw">in</span> inet.edges()]</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>ipos <span class="op">=</span> nx.nx_pydot.graphviz_layout(inet)</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>nx.draw(inet, </span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>        node_color <span class="op">=</span> <span class="st">'black'</span>,</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> ipos,</span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>        with_labels <span class="op">=</span> <span class="va">True</span>, </span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>        font_color <span class="op">=</span> <span class="st">'white'</span>, </span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>        font_size <span class="op">=</span> <span class="dv">8</span>, </span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>        width<span class="op">=</span>np.array(weights)<span class="op">/</span><span class="dv">6</span>, <span class="co"># transform edge weights</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>        edge_color <span class="op">=</span> <span class="st">"gray"</span>)</span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_08.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_08" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_08.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.6: png</figcaption>
</figure>
</div>
<p>To help interpret this induced graph, we can look up the names of the nodes in each community. For example, if we wanted to know which nodes make up the Community 2 node:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>community <span class="op">=</span> <span class="dv">14</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k,v <span class="kw">in</span> part.items():</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="op">==</span> community:</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(k)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The Louvain algorithm does a reasonably good job of identifying cohesive subgroups in networks, but there are some non-trivial limitations in the algorithm. The most obvious of these limitations are that (1) nodes must belong to one and only one community because communities can’t overlap, and (2) small communities may not be accurately identified and may end up being merged into larger communities. Earlier, I discussed some issues with the algorithm, raised by <span class="citation" data-cites="traag2019louvain">Traag, Waltman, and Van Eck (<a href="references.html#ref-traag2019louvain" role="doc-biblioref">2019</a>)</span>.</p>
<section id="from-louvain-to-leiden" class="level4" data-number="17.5.2.1">
<h4 data-number="17.5.2.1" class="anchored" data-anchor-id="from-louvain-to-leiden"><span class="header-section-number">17.5.2.1</span> From Louvain to Leiden</h4>
<p>To address the issues they identified with Louvain, <span class="citation" data-cites="traag2019louvain">Traag, Waltman, and Van Eck (<a href="references.html#ref-traag2019louvain" role="doc-biblioref">2019</a>)</span> propose the Leiden algorithm; it includes some additional processes that give it more flexibility about how it treats communities and the nodes within them. While Louvain optimizes modularity by moving individual nodes to other communities and then kicks off the aggregation step to choose community merges, Leiden adds a step in the middle where each community is considered in isolation and its modularity is maximized. In this way, a poorly connected community that should be split into multiple smaller communities doesn’t end up swallowed up as a single unhappy unit in the aggregation stage that follows. Aside from guaranteeing that all of the communities identified will actually be connected, this optimal sub-community assignment also allows Leiden to find smaller, distinct communities. Leiden also implements a number of clever performance refinements that have been proposed to improve Louvain’s often lengthy convergence time. These are less important to understanding how and when to use Leiden for community detection, so we don’t need to get to the bottom of them here.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Instead, let’s see some example results from applying Leiden to the same data we used the Louvain algorithm on above!</p>
<p>Leiden is available for Python via pip, but it requires the package python-igraph as a dependency. igraph is substantially more performant than NetworkX due to the C++ backend that it’s built around, but the documentation (for the Python implementation) is not nearly as extensive as NetworkX, which is one of the reasons why we have used NetworkX so far.</p>
<p>Let’s start by building an iGraph undirected graph object, basically identical to the one above. Thankfully, our pandas dataframe is in exactly the format that iGraph expects, where the first two columns are the <code>from</code> and <code>to</code> nodes from NetworkX terminology.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> igraph <span class="im">as</span> ig</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> leidenalg <span class="im">as</span> la</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We create the network object, then use leidenalg to calculate the partition memberships for each node.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> ig.Graph.DataFrame(</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    contact_diaries, </span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    directed <span class="op">=</span> <span class="va">False</span>,</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>    vertices<span class="op">=</span><span class="va">None</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'name'</span> <span class="kw">not</span> <span class="kw">in</span> H.vs.attributes():</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    H.vs[<span class="st">'name'</span>] <span class="op">=</span> [<span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(H.vcount())]</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>part_leiden <span class="op">=</span> la.find_partition(H, la.ModularityVertexPartition)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For consistency, it’s nice to be able to use the same layout for a graph to compare the community detection results. Drawing graphs in networkx is also quite a lot more straightforward and the graphviz layout algorithm produces nice layouts. We can access attributes of the leidenalg <code>partition</code> class object to modify a copy of the networkx partition object, which is just a dictionary of <code>{node_name:community_id}</code>. The attribute <code>_graph</code> of the <code>partition</code> class is itself an iGraph <code>graph</code> class, from which we can access the <code>.vs['name']</code> attribute that is populated from the dataframe and will match the networkx node names.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>partition <span class="op">=</span> part.copy()</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> membership, node <span class="kw">in</span> <span class="bu">zip</span>(part_leiden._membership, part_leiden._graph.vs[<span class="st">'name'</span>]):</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    partition[node] <span class="op">=</span> membership</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we can draw the graph just as we did with the networks above. You will notice, from Figure <a href="#fig-14_09">Figure&nbsp;<span>17.7</span></a> (once again, printed in grayscale but with a full color version available in the online supplementary learning materials), that we end up with more communities here than we did with Louvain community detection, and some are considerably smaller. Also note that although the communities in the bottom left of the graph seem pretty intermingled, this is because the layout was calculated only by the connections between nodes, rather than any sophisticated community detection. Importantly, none of these communities have disconnected nodes despite being split into twice the communities detected by Louvain, which is a promise of the Leiden algorithm.</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [partition[n] <span class="cf">for</span> n <span class="kw">in</span> G.nodes()]</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>my_colors <span class="op">=</span> plt.cm.Set2</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G,</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>                       pos<span class="op">=</span>layout,</span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>                       node_size<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>                       node_color<span class="op">=</span>colors,</span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>                       cmap<span class="op">=</span>my_colors)</span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G, pos<span class="op">=</span>layout, edge_color<span class="op">=</span><span class="st">'lightgray'</span>, width<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_09.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_09" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_09.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.7: png</figcaption>
</figure>
</div>
<p>The leidenalg package also accepts directed networks with edge weights - we will provide those to the partition detection function and then see how much it changes the communities that are detected.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>dH <span class="op">=</span> ig.Graph.DataFrame(contact_diaries, directed <span class="op">=</span> <span class="va">True</span>, vertices<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'name'</span> <span class="kw">not</span> <span class="kw">in</span> dH.vs.attributes():</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    dH.vs[<span class="st">'name'</span>] <span class="op">=</span> [<span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(dH.vcount())]</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>part_leiden <span class="op">=</span> la.find_partition(dH, la.ModularityVertexPartition, weights <span class="op">=</span> dH.es[<span class="st">'weight'</span>])</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> membership, node <span class="kw">in</span> <span class="bu">zip</span>(part_leiden._membership, part_leiden._graph.vs[<span class="st">'name'</span>]):</span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>    partition[node] <span class="op">=</span> membership</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the resulting image (Figure <a href="#fig-14_10">Figure&nbsp;<span>17.8</span></a>), it’s possible to simply observe the changes because there’s actually only one! The middle community at the top of the graph is split into two individual communities.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [partition[n] <span class="cf">for</span> n <span class="kw">in</span> G.nodes()]</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>my_colors <span class="op">=</span> plt.cm.Set2</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(G,</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>                       pos<span class="op">=</span>layout,</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>                       node_size<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>                       node_color<span class="op">=</span>colors,</span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>                       cmap<span class="op">=</span>my_colors)</span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(G, pos<span class="op">=</span>layout, edge_color<span class="op">=</span><span class="st">'lightgray'</span>, width<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_10.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_10" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_10.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.8: png</figcaption>
</figure>
</div>
</section>
</section>
<section id="components-and-k-cores" class="level3" data-number="17.5.3">
<h3 data-number="17.5.3" class="anchored" data-anchor-id="components-and-k-cores"><span class="header-section-number">17.5.3</span> Components and <span class="math inline">\(k\)</span>-cores</h3>
<section id="components" class="level4" data-number="17.5.3.1">
<h4 data-number="17.5.3.1" class="anchored" data-anchor-id="components"><span class="header-section-number">17.5.3.1</span> Components</h4>
<p>The <span class="math inline">\(k\)</span>-clique, Louvain, and Leiden approaches to subgroup detection that we have covered so far detect higher-level structures (communities) by working their way <em>up</em> from lower-level structures. Now we are going to switch our focus to another set of approaches that work the opposite way: from the top down. The first thing we need to do is discuss <strong>components</strong>. A component is simply a connected graph. Most of the networks we have seen so far have been single components, but we have seen a few examples where a few nodes exist off on their own, detached from the rest of the networks. In those cases, each connected group of nodes is a component. Components are generally not considered “communities” in and of themselves, but they are the starting point for community detection algorithms that start at the top level of a network and work their way down to the lower levels of a network, revealing increasingly cohesive subgroups of nodes along the way.</p>
<p>Networkx makes it easy to figure out how many components a network has. In this case we already know the answer from the network visualizations above (3), but let’s execute the code anyway.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>nx.number_connected_components(G)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can use a bit of list comprehension to get the number of nodes in each component</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>comps_sizes <span class="op">=</span> [<span class="bu">len</span>(c) <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">sorted</span>(nx.connected_components(G), key<span class="op">=</span><span class="bu">len</span>, reverse<span class="op">=</span><span class="va">True</span>)]</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(comps_sizes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The largest component in this network has 128 nodes. Generally, we refer to the largest component in a network as the <strong>giant component</strong>.</p>
<p>Many network methods require operating on a connected graph (i.e.&nbsp;a single component). We now know the network we are working with – like many real world networks – is not fully connected. If we need to use a method or a model that requires a fully connected network, there are a number of possible actions we could take. One would be to decompose the network into separate networks for each component and analyze each separately. Alternatively, we could extract the giant component by identifying all the components in the network (“connected component subgraphs”) and then selecting the largest one.</p>
<p>As the first method conducts the same analysis as the second, in addition to the smaller components, working with only the giant component is best done when the non-giant components tend to be much smaller. For example, if your network contains a lot of isolated dyads separated from the giant component, there is little we that could be meaningfully done with their community structure.</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>components <span class="op">=</span> <span class="bu">sorted</span>(nx.connected_components(G), key<span class="op">=</span><span class="bu">len</span>, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>giant <span class="op">=</span> G.subgraph(components[<span class="dv">0</span>])</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>giant.name <span class="op">=</span> <span class="st">"Communication Network, Giant Component"</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(giant)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="k-cores" class="level4" data-number="17.5.3.2">
<h4 data-number="17.5.3.2" class="anchored" data-anchor-id="k-cores"><span class="header-section-number">17.5.3.2</span> <span class="math inline">\(k\)</span>-Cores</h4>
<p>From a top-down perspective on community structure, components are a bit like Russian nesting dolls; the component itself is “cohesive” insofar as it is, and stays, connected, but much <em>more</em> cohesive subgroups, such as cliques, are nested inside them. Just as we worked our way <em>up</em> to communities earlier, we can work out <em>down</em> from components to reveal more cohesive groups inside of components.</p>
<p>With social networks, it is common to find a set of nodes that are densely connected with one another. These often form <strong>the “core” of a component</strong>, and as you move further away from that densely connected core towards the edges of the network, you find nodes that are less densely connected. This is typically referred to as a <strong>core-periphery structure</strong>.</p>
<p><strong><span class="math inline">\(k\)</span>-cores</strong> are one of the most common ways of identifying the cohesive group(s) of nodes at the core of a component. In this approach, <span class="math inline">\(k\)</span> represents a minimum degree value. For example, if <span class="math inline">\(k\)</span> = 5, then the <span class="math inline">\(k\)</span>-core will consist of the largest connected subgraph where all nodes have <em>at least</em> a degree of 5. A <span class="math inline">\(k\)</span>-core with <span class="math inline">\(k=2\)</span> would be made up of nodes with a degree of at least 2, and so on. As the value of <span class="math inline">\(k\)</span> increases, denser and more cohesive regions of the component are revealed. Note that the definition of <span class="math inline">\(k\)</span>-core accounts for a node’s degree before identifying the core, so such an analysis could reveal pockets of dense connections which are themselves only weakly connected. For example, imagine a long chain of nodes with a degree of 4: each node in the chain is connected to the next and has an additional 2 pendants hanging off. The backbone of this chain would be identified by a 4-core, while the pendants would not.</p>
<p>Let’s extract a series of <span class="math inline">\(k\)</span>-cores from the SocioPatterns contact diaries network (<code>G</code>) and compare the number of nodes and edges that are part of the <span class="math inline">\(k\)</span>-core at different values for <span class="math inline">\(k\)</span>.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>ks <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>nnodes <span class="op">=</span> []</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>nedges <span class="op">=</span> []</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> ks:</span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>    kcore <span class="op">=</span> nx.k_core(G, k)</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>    nnodes.append(kcore.number_of_nodes())</span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>    nedges.append(kcore.number_of_edges())</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>kdf <span class="op">=</span> pd.DataFrame([ks,nnodes,nedges]).T</span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>kdf.columns <span class="op">=</span> [<span class="st">'Value of K'</span>, <span class="st">'Number of Nodes'</span>, <span class="st">'Number of Edges'</span>]</span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a>kdf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can see here that <em>if there were isolates in this network</em>, they would have been dropped by <span class="math inline">\(k\)</span> = 1. The number of nodes and edges in the network drops slightly with <span class="math inline">\(k\)</span> = 2. There are fairly large drops in size for <span class="math inline">\(k\)</span> = 3 and 4. No nodes or edges are retained for <span class="math inline">\(k\)</span> = 8 in this particular network.</p>
<p>Let’s see what the <span class="math inline">\(k\)</span>-cores look like for <span class="math inline">\(k=4\)</span> and <span class="math inline">\(k=5\)</span>. To do so, we will extract and then visualize the <span class="math inline">\(k\)</span>-core subgraphs overlaid on the full network.</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>kcore_4 <span class="op">=</span> nx.k_core(G, <span class="dv">4</span>)</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>kcore_5 <span class="op">=</span> nx.k_core(G, <span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To emphasize the <em>nestedness</em> of these <span class="math inline">\(k\)</span>-cores, let’s layer visualizations of each. In the Figure below, we first draw our base graph, with all nodes and edges in the giant component in light gray. Then we overlay a visualization of the 4-core using the same layout coordinates, but coloring the nodes and edges dark gray (the color palette I can use for this book is highly constrained!). Finally, we overlay a visualization (Figure <a href="#fig-14_11">Figure&nbsp;<span>17.9</span></a>) of the 5-core, again using the same layout coordinates but coloring the nodes and edges crimson. The resulting visualization shows how the most locally dense regions of the network are embedded in larger and less cohesive regions of the network, <em>much like the Russian nesting dolls previously mentioned</em>.</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="co">## BASE NETWORK</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>nx.draw(G, layout, node_color <span class="op">=</span> <span class="st">'lightgray'</span>, edge_color <span class="op">=</span> <span class="st">'lightgray'</span>, node_size <span class="op">=</span> <span class="dv">30</span>)</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a><span class="co">## DRAW THE NODES IN THE 4-CORE GRAY</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(kcore_4, layout, node_size <span class="op">=</span> <span class="dv">30</span>, node_color <span class="op">=</span> <span class="st">'gray'</span>)</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(kcore_4, layout, node_size <span class="op">=</span> <span class="dv">30</span>, edge_color <span class="op">=</span> <span class="st">'gray'</span>)</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="co">## DRAW THE NODES IN THE 5-CORE IN CRIMSON</span></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_nodes(kcore_5, layout, node_size <span class="op">=</span> <span class="dv">30</span>, node_color <span class="op">=</span> <span class="st">'crimson'</span>)</span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx_edges(kcore_5, layout, node_size <span class="op">=</span> <span class="dv">30</span>, edge_color <span class="op">=</span> <span class="st">'crimson'</span>)</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'figures/14_11.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-14_11" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="figures/14_11.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;17.9: png</figcaption>
</figure>
</div>
<p>These visualizations should help build some intuition for how <span class="math inline">\(k\)</span>-cores work, and how they can help you uncover a particular type of network structure with a cohesive subgroup, or several groups, at the core of a component, and more peripheral nodes loosely connected to the core.</p>
<blockquote class="blockquote">
<p><strong>Further Reading</strong></p>
<p>If you are looking to learn more on cohesive subgroups and community structure, Chapter 11 of Borgatti, Everett, and Johnson’s <span class="citation" data-cites="borgatti2018analyzing">(<a href="references.html#ref-borgatti2018analyzing" role="doc-biblioref">2018</a>)</span> <em>Analyzing Social Networks</em> provides a good overview.</p>
</blockquote>
</section>
</section>
</section>
<section id="conclusion-1" class="level2" data-number="17.6">
<h2 data-number="17.6" class="anchored" data-anchor-id="conclusion-1"><span class="header-section-number">17.6</span> CONCLUSION</h2>
<section id="key-points-1" class="level3" data-number="17.6.1">
<h3 data-number="17.6.1" class="anchored" data-anchor-id="key-points-1"><span class="header-section-number">17.6.1</span> Key Points</h3>
<ul>
<li>Dyads (two nodes) and triads (three nodes) are the primary micro-structures that are used to describe networks</li>
<li>Conducted a triad census</li>
<li>Learned how micro-structures combine to create larger macro-structures like cliques and communities (bottom-up)</li>
<li>Learned how network structure can be broken down to find smaller sub-groups (top-down)</li>
<li>Conducted a community analysis using <span class="math inline">\(k\)</span>-clique communities, Louvain community detection algorithm, <span class="math inline">\(k\)</span>-components, and <span class="math inline">\(k\)</span>-core decomposition</li>
</ul>
</section>
</section>
<section id="section" class="level2" data-number="17.7">
<h2 data-number="17.7" class="anchored" data-anchor-id="section"><span class="header-section-number">17.7</span> </h2>
<p><br><br></p>
<p><img src="media/heuristic.png" class="shadow-img img-fluid" style="width:40.0%"></p>
<section id="pitfalls-and-problems-with-heuristic-network-analysis" class="level3" data-number="17.7.1">
<h3 data-number="17.7.1" class="anchored" data-anchor-id="pitfalls-and-problems-with-heuristic-network-analysis"><span class="header-section-number">17.7.1</span> pitfalls and problems <br>with <span class="kn-pink">heuristic</span> network analysis</h3>
</section>
</section>
<section id="section-1" class="level2" data-number="17.8">
<h2 data-number="17.8" class="anchored" data-anchor-id="section-1"><span class="header-section-number">17.8</span> </h2>
<div class="columns">
<div class="column" style="width:50%;">
<div id="fig-divided_they_blog" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="media/divided_they_blog.png" class="shadow-img img-fluid figure-img" style="width:100.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;17.10: <strong>?(caption)</strong></figcaption>
</figure>
</div>
<section id="divided-they-blog-2" class="level3" data-number="17.8.1">
<h3 data-number="17.8.1" class="anchored" data-anchor-id="divided-they-blog-2"><span class="header-section-number">17.8.1</span> Divided They Blog</h3>
</section>
</div><div class="column" style="width:50%;">
<p><span class="math inline">\(\longleftarrow\)</span><br>This famous figure from <span class="citation" data-cites="adamic2005political">(<a href="references.html#ref-adamic2005political" role="doc-biblioref"><strong>adamic2005political?</strong></a>)</span> shows a conservative-liberal divide in the American political blogosphere circa 2004.</p>
<ul>
<li>Nodes: political blogs</li>
<li>Edges: links <span class="nord-light">(“citations”)</span> to other blogs</li>
<li>Color: liberal (blue), conservative (red) <span class="nord-light">(not CD!)</span></li>
<li>Size: indegree</li>
<li>Layout: force directed</li>
</ul>
<p><br></p>
<p><span class="fragment">Is the network structure<br><span class="large-text"><span class="kn-pink">self-evident</span></span><br>here?</span></p>
</div>
</div>
</section>
<section id="section-2" class="level2" data-number="17.9">
<h2 data-number="17.9" class="anchored" data-anchor-id="section-2"><span class="header-section-number">17.9</span> </h2>
<div class="columns">
<div class="column" style="width:55%;">
<div id="fig-data-science" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="media/data-science.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;17.11: Wickham’s loop.</figcaption>
</figure>
</div>
<p><br></p>
<section id="common-first-steps" class="level3" data-number="17.9.1">
<h3 data-number="17.9.1" class="anchored" data-anchor-id="common-first-steps"><span class="header-section-number">17.9.1</span> Common First Steps</h3>
<ul>
<li>reduce the network <span class="nord-light">(e.g., detect subgroup structure)</span></li>
<li>visualize network <span class="nord-light">(usually force-directed layouts)</span></li>
<li>interpret and …</li>
</ul>
<p>When do we exit the loop?</p>
<p>Can we trust intuition?</p>
</section>
</div><div class="column" style="width:5%;">

</div><div class="column" style="width:40%;">
<div id="fig-box_loop" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="media/box_loop.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption class="figure-caption">Figure&nbsp;17.12: Box’s loop.</figcaption>
</figure>
</div>
<p><br></p>
<p><img src="media/divided_they_blog.png" class="shadow-img img-fluid" style="width:60.0%"></p>
</div>
</div>
</section>
<section id="section-3" class="level2" data-number="17.10">
<h2 data-number="17.10" class="anchored" data-anchor-id="section-3"><span class="header-section-number">17.10</span> </h2>
<div class="columns">
<div class="column" style="width:50%;">
<p><img src="media/divided_they_blog.png" class="shadow-img img-fluid" style="width:100.0%"></p>
<section id="how-sure-are-you" class="level3" data-number="17.10.1">
<h3 data-number="17.10.1" class="anchored" data-anchor-id="how-sure-are-you"><span class="header-section-number">17.10.1</span> How sure are you?</h3>
</section>
</div><div class="column" style="width:50%;">
<p><br></p>
<section id="common-pitfalls-and-problems" class="level4" data-number="17.10.1.1">
<h4 data-number="17.10.1.1" class="anchored" data-anchor-id="common-pitfalls-and-problems"><span class="header-section-number">17.10.1.1</span> Common pitfalls and problems</h4>
<p><span class="nord-footer"><span class="citation" data-cites="peixoto2021modularity">(<a href="references.html#ref-peixoto2021modularity" role="doc-biblioref"><strong>peixoto2021modularity?</strong></a>)</span>; <span class="citation" data-cites="peixoto2023descriptive">(<a href="references.html#ref-peixoto2023descriptive" role="doc-biblioref"><strong>peixoto2023descriptive?</strong></a>)</span>; <span class="citation" data-cites="peixoto2021hairball">(<a href="references.html#ref-peixoto2021hairball" role="doc-biblioref"><strong>peixoto2021hairball?</strong></a>)</span></span></p>
<ul>
<li>(Implicitly?) believing some approaches are more “model-free” than others</li>
<li>(Implicitly?) believing that network structure will be self-evident and our intuitions will hold up when reasoning about high-dimensional network structure</li>
</ul>
<p><br></p>
<p>Which often translates to:</p>
<ul>
<li>using heuristic approaches <span class="nord-light">(esp.&nbsp;modularity-maximization)</span> to partition/reduce networks</li>
<li>interpreting generic network visualizations <span class="nord-light">(esp.&nbsp;force-directed)</span> without sufficient model criticism</li>
</ul>
</section>
</div>
</div>
</section>
<section id="section-4" class="level2" data-number="17.11">
<h2 data-number="17.11" class="anchored" data-anchor-id="section-4"><span class="header-section-number">17.11</span> </h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/box_loop.png" class="shadow-img img-fluid figure-img" style="width:80.0%"></p>
<figcaption class="figure-caption">These loops encourage us to explicate, criticize, and refine <strong>models</strong> in order to be confident in our inferences.</figcaption>
</figure>
</div>
<p>There is <span class="kn-blue">no inference without models</span>, so we should always make our models explicit.</p>
</section>
<section id="section-5" class="level2" data-number="17.12">
<h2 data-number="17.12" class="anchored" data-anchor-id="section-5"><span class="header-section-number">17.12</span> </h2>
<section id="heuristic-community-detection-via-modularity-maximization" class="level3" data-number="17.12.1">
<h3 data-number="17.12.1" class="anchored" data-anchor-id="heuristic-community-detection-via-modularity-maximization"><span class="header-section-number">17.12.1</span> Heuristic Community Detection<br>via Modularity Maximization</h3>
<p><br><br></p>
<div class="columns">
<div class="column" style="width:55%;">
<p>The Louvain <span class="nord-light"><span class="citation" data-cites="blondel2008fast">(<a href="references.html#ref-blondel2008fast" role="doc-biblioref"><strong>blondel2008fast?</strong></a>)</span></span> algorithm purports to detect communities in networks by maximizing a “modularity” score <span class="math inline">\(Q\)</span> <span class="nord-light"><span class="citation" data-cites="newman2004finding">(<a href="references.html#ref-newman2004finding" role="doc-biblioref"><strong>newman2004finding?</strong></a>)</span></span>, where higher <span class="math inline">\(Q\)</span> values indicate more modular networks.</p>
<p><img src="media/Louvain.png" class="img-fluid" style="width:100.0%"></p>
</div><div class="column" style="width:5%;">

</div><div class="column" style="width:40%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/Louvain_alg.png" class="shadow-img img-fluid figure-img" style="width:100.0%"></p>
<figcaption class="figure-caption">Figure reproduced from <span class="nord-light"><span class="citation" data-cites="blondel2008fast">(<a href="references.html#ref-blondel2008fast" role="doc-biblioref"><strong>blondel2008fast?</strong></a>)</span></span></figcaption>
</figure>
</div>
</div>
</div>
<div class="notes">
<p>It starts by assuming that every node in a network is in it’s own community and calculates a modularity score <span class="math inline">\(Q\)</span> for the network. Nodes are then randomly moved into different groups and <span class="math inline">\(Q\)</span> is re-calculated. If it increased, the community assignment is retained. This process continues until the node assignments have maximized <span class="math inline">\(Q\)</span> at the level of the observed network.</p>
<p>Next, a simplified network is created by aggregating nodes into their assigned communities and the modularity maximization process is repeated. Communities are merged with other communities, and the mergers are retained if <span class="math inline">\(Q\)</span> increases. This process continues iteratively until <span class="math inline">\(Q\)</span> has been maximized.</p>
</div>
</section>
</section>
<section id="section-6" class="level2" data-number="17.13">
<h2 data-number="17.13" class="anchored" data-anchor-id="section-6"><span class="header-section-number">17.13</span> </h2>
<div class="columns">
<div class="column" style="width:55%;">
<p><span class="large-text">😲😰😰😰</span></p>
<p>Some <strong>well-known problems</strong>:</p>
<ul>
<li>the resolution limit</li>
<li>getting stuck in local optima</li>
<li>creating disconnected communities</li>
<li>can only identify assortative structure</li>
<li>finds “communities” in random networks</li>
<li>the illusion of greater objectivity<br><span class="nord-footer"><span class="citation" data-cites="moody2023cohesion">(see <a href="references.html#ref-moody2023cohesion" role="doc-biblioref"><strong>moody2023cohesion?</strong></a>)</span></span></li>
<li>simultaneously over- and under-fit<br><span class="nord-footer"><span class="citation" data-cites="peixoto2023descriptive">(see <a href="references.html#ref-peixoto2023descriptive" role="doc-biblioref"><strong>peixoto2023descriptive?</strong></a>)</span></span></li>
<li>often has a degenerate solution space<br><span class="nord-footer"><span class="citation" data-cites="peixoto2023descriptive">(see <a href="references.html#ref-peixoto2023descriptive" role="doc-biblioref"><strong>peixoto2023descriptive?</strong></a>)</span></span></li>
<li>etc.</li>
</ul>
<p><span class="fragment">There have been some improvements to modularity-maximization approaches <span class="nord-light"><span class="citation" data-cites="traag2019louvain">(e.g., <a href="references.html#ref-traag2019louvain" role="doc-biblioref">Traag, Waltman, and Van Eck 2019</a>)</span></span>, but these only go so far. There are <strong>fundamental problems</strong> with the modularity-maximization idea, and heuristic approaches in general.</span></p>
</div><div class="column" style="width:45%;">

</div>
</div>
<div class="notes">
<p>…</p>
<p>There are well-known problems with the Louvain algorithm, including <strong>the resolution limit</strong>, which prevents Louvain from detecting meaningful small communities due to inappropriate merging at higher levels. Louvain can also get <strong>stuck in local optima</strong>, causing it to stop looking for better partitions because it “thinks” (incorrectly) that <span class="math inline">\(Q\)</span> has been maximized. And sometimes it <strong>creates disconnected communities</strong>!</p>
</div>
</section>
<section id="section-7" class="level2" data-number="17.14">
<h2 data-number="17.14" class="anchored" data-anchor-id="section-7"><span class="header-section-number">17.14</span> </h2>
<section id="what-is-q" class="level3" data-number="17.14.1">
<h3 data-number="17.14.1" class="anchored" data-anchor-id="what-is-q"><span class="header-section-number">17.14.1</span> What is <span class="math inline">\(Q\)</span>?</h3>
<p><span class="nord-footer"><span class="citation" data-cites="newman2004finding blondel2008fast">(<a href="references.html#ref-newman2004finding" role="doc-biblioref"><strong>newman2004finding?</strong></a>; <a href="references.html#ref-blondel2008fast" role="doc-biblioref"><strong>blondel2008fast?</strong></a>)</span></span></p>
<p><br></p>
<div class="columns">
<div class="column" style="width:45%;">
<p><span class="math display">\[
Q(A, b) = \frac{1}{2E} \sum_{ij} \left( A_{ij} - \gamma \frac{k_i k_j}{2E} \right) \delta_{b_i, b_j}
\]</span></p>
</div><div class="column" style="width:10%;">

</div><div class="column" style="width:45%;">
<p><span class="math inline">\(A\)</span> is the binary adjacency matrix for an observed network and <span class="math inline">\(b\)</span> is a vector of node community assignments, so <span class="math inline">\(Q(A,b)\)</span> is the modularity score we would obtain for matrix <span class="math inline">\(A\)</span> given a proposed vector of community assignments <span class="math inline">\(b\)</span>.</p>
<p><br></p>
<p>The goal is to find <span class="math inline">\(\hat{b}\)</span>, the vector <span class="math inline">\(b\)</span> that maximizes <span class="math inline">\(Q\)</span>.</p>
<p><span class="math display">\[
\hat{b} = \mathop{\mathrm{argmax}}_{b} \, Q(A, b)
\]</span></p>
<!-- $$
More recent version include a [resolution parameter]{.kn-pink} $\gamma$ that determines how the algorithm considers within community edges relative to a null model. Larger $\gamma$ values tend to result in a larger number of smaller communities. In the original equation ($\longleftarrow$), this was set to 1 by default, which **gave the impression** that researchers could find the optimal community partition with little subjective judgement. -->
</div>
</div>
</section>
</section>
<section id="section-8" class="level2" data-number="17.15">
<h2 data-number="17.15" class="anchored" data-anchor-id="section-8"><span class="header-section-number">17.15</span> </h2>
<section id="what-is-q-1" class="level3" data-number="17.15.1">
<h3 data-number="17.15.1" class="anchored" data-anchor-id="what-is-q-1"><span class="header-section-number">17.15.1</span> What is <span class="math inline">\(Q\)</span>?</h3>
<p><span class="nord-footer"><span class="citation" data-cites="newman2004finding blondel2008fast">(<a href="references.html#ref-newman2004finding" role="doc-biblioref"><strong>newman2004finding?</strong></a>; <a href="references.html#ref-blondel2008fast" role="doc-biblioref"><strong>blondel2008fast?</strong></a>)</span></span></p>
<p><br></p>
<div class="columns">
<div class="column" style="width:40%;">
<p><span class="math display">\[
Q(A, b) = \frac{1}{2E} \sum_{ij} \left( A_{ij} - \gamma \frac{k_i k_j}{2E} \right) \delta_{b_i, b_j}
\]</span></p>
<p><span class="math display">\[
\hat{b} = \mathop{\mathrm{argmax}}_{b} \, Q(A, b)
\]</span></p>
</div><div class="column" style="width:10%;">

</div><div class="column" style="width:50%;">
<ul>
<li><span class="math inline">\(E\)</span> is the total weight of edges in the network.</li>
<li><span class="math inline">\(A_{ij}\)</span> is a specific entry in <span class="math inline">\(A\)</span> <span class="nord-light">(<span class="math inline">\(A_{ij} \in \{0, 1\}\)</span> if <span class="math inline">\(A\)</span> is binary)</span>.</li>
<li><span class="math inline">\(\gamma\)</span> is a resolution parameter <span class="nord-light">(more recent addition)</span> that governs the size and number of communities detected.</li>
<li><span class="math inline">\(\frac{k_i k_j}{2E}\)</span> is a null model for baseline expectations <span class="nord-light">(next slide)</span>.</li>
<li><span class="math inline">\(\delta(c_i, c_j)\)</span> is an indicator function that equals 1 if <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are in the same community and 0 if not. This limits the summation to within-community edges.</li>
<li>Normalizing with <span class="math inline">\(\frac{1}{2E}\)</span> constrains the maximum modularity score to 1.</li>
<li><span class="math inline">\(\hat{b}\)</span> is the vector of community assignments <span class="math inline">\(b\)</span> with the maximum <span class="math inline">\(Q\)</span> score.</li>
</ul>
</div>
</div>
</section>
</section>
<section id="section-9" class="level2" data-number="17.16">
<h2 data-number="17.16" class="anchored" data-anchor-id="section-9"><span class="header-section-number">17.16</span> </h2>
<section id="what-is-q-2" class="level3" data-number="17.16.1">
<h3 data-number="17.16.1" class="anchored" data-anchor-id="what-is-q-2"><span class="header-section-number">17.16.1</span> What is <span class="math inline">\(Q\)</span>?</h3>
<p><span class="nord-footer"><span class="citation" data-cites="newman2004finding blondel2008fast">(<a href="references.html#ref-newman2004finding" role="doc-biblioref"><strong>newman2004finding?</strong></a>; <a href="references.html#ref-blondel2008fast" role="doc-biblioref"><strong>blondel2008fast?</strong></a>)</span></span></p>
<p><br></p>
<div class="columns">
<div class="column" style="width:40%;">
<p><span class="math display">\[
Q(A, b) = \frac{1}{2E} \sum_{ij} \left( A_{ij} - \gamma \frac{k_i k_j}{2E} \right) \delta_{b_i, b_j}
\]</span></p>
<p><span class="math display">\[
\hat{b} = \mathop{\mathrm{argmax}}_{b} \, Q(A, b)
\]</span></p>
</div><div class="column" style="width:5%;">

</div><div class="column" style="width:55%;">
<p><span class="math inline">\(\frac{k_i k_j}{2E}\)</span> represents the edges expected under a <strong>null model with no community structure at all</strong>, in which the probability of an edge is proportional to node degrees (<span class="math inline">\(k_i k_j\)</span>) and otherwise random.</p>
<p><br></p>
<p>The resolution parameter <span class="math inline">\(\gamma\)</span> varies the number and size of clusters identified by weighting the comparison of observed edges with edges expected under this <span class="nord-light">entirely implausible and inappropriate</span> null model.</p>
<p><span class="math display">\[
\sum_{ij} \left( A_{ij} - \gamma \frac{k_i k_j}{2E} \right)
\]</span></p>
<p>This is not good inference.</p>
</div>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" role="list" style="display: none">
<div id="ref-borgatti2018analyzing" class="csl-entry" role="listitem">
Borgatti, Stephen, Martin Everett, and Jeffrey Johnson. 2018. <em>Analyzing Social Networks</em>. Sage.
</div>
<div id="ref-davis1967structure" class="csl-entry" role="listitem">
Davis, James A, and Samuel Leinhardt. 1967. <span>“The Structure of Positive Interpersonal Relations in Small Groups.”</span>
</div>
<div id="ref-doreian2002positional" class="csl-entry" role="listitem">
Doreian, Patrick, Vladimir Batagelj, and Anuska Ferligoj. 2002. <em>Positional Analyses of Sociometric Data</em>. University of Ljubljana, Institute of Mathematics, Physics; Mechanics&nbsp;….
</div>
<div id="ref-doreian2005generalized" class="csl-entry" role="listitem">
———. 2005. <em>Generalized Blockmodeling</em>. 25. Cambridge university press.
</div>
<div id="ref-ferligoj2011positions" class="csl-entry" role="listitem">
Ferligoj, Anuska, Patrick Doreian, and Vladimir Batagelj. 2011. <span>“Positions and Roles.”</span> <em>The SAGE Handbook of Social Network Analysis</em>, 434–46.
</div>
<div id="ref-gerlach2018network" class="csl-entry" role="listitem">
Gerlach, Martin, Tiago Peixoto, and Eduardo Altmann. 2018. <span>“A Network Approach to Topic Models.”</span> <em>Science Advances</em> 4 (7): eaaq1360.
</div>
<div id="ref-holland1983stochastic" class="csl-entry" role="listitem">
Holland, Paul, Kathryn Blackmond Laskey, and Samuel Leinhardt. 1983. <span>“Stochastic Blockmodels: First Steps.”</span> <em>Social Networks</em> 5 (2): 109–37.
</div>
<div id="ref-karrer2011stochastic" class="csl-entry" role="listitem">
Karrer, Brian, and Mark Newman. 2011. <span>“Stochastic Blockmodels and Community Structure in Networks.”</span> <em>Physical Review E</em> 83 (1): 016107.
</div>
<div id="ref-lorrain1971structural" class="csl-entry" role="listitem">
Lorrain, Francois, and Harrison C White. 1971. <span>“Structural Equivalence of Individuals in Social Networks.”</span> <em>The Journal of Mathematical Sociology</em> 1 (1): 49–80.
</div>
<div id="ref-nowicki2001estimation" class="csl-entry" role="listitem">
Nowicki, Krzysztof, and Tom Snijders. 2001. <span>“Estimation and Prediction for Stochastic Blockstructures.”</span> <em>Journal of the American Statistical Association</em> 96 (455): 1077–87.
</div>
<div id="ref-palla2005uncovering" class="csl-entry" role="listitem">
Palla, Gergely, Imre Derényi, Illés Farkas, and Tamás Vicsek. 2005. <span>“Uncovering the Overlapping Community Structure of Complex Networks in Nature and Society.”</span> <em>Nature</em> 435 (7043): 814–18.
</div>
<div id="ref-peixoto2014hierarchical" class="csl-entry" role="listitem">
Peixoto, Tiago. 2014. <span>“Hierarchical Block Structures and High-Resolution Model Selection in Large Networks.”</span> <em>Physical Review X</em> 4 (1): 011047.
</div>
<div id="ref-peixoto2019bayesian" class="csl-entry" role="listitem">
Peixoto, Tiago P. 2019. <span>“Bayesian Stochastic Blockmodeling.”</span> <em>Advances in Network Clustering and Blockmodeling</em>, 289–332.
</div>
<div id="ref-cprell" class="csl-entry" role="listitem">
Prell, Christina. 2013. <em>Social Network Analysis</em>. Sage.
</div>
<div id="ref-jscott" class="csl-entry" role="listitem">
Scott, John. 2013. <em>Social Network Analysis</em>. Sage.
</div>
<div id="ref-snijders1997estimation" class="csl-entry" role="listitem">
Snijders, Tom, and Krzysztof Nowicki. 1997. <span>“Estimation and Prediction for Stochastic Blockmodels for Graphs with Latent Block Structure.”</span> <em>Journal of Classification</em> 14 (1): 75–100.
</div>
<div id="ref-traag2019louvain" class="csl-entry" role="listitem">
Traag, Vincent A, Ludo Waltman, and Nees Jan Van Eck. 2019. <span>“From Louvain to Leiden: Guaranteeing Well-Connected Communities.”</span> <em>Scientific Reports</em> 9 (1): 1–12.
</div>
<div id="ref-wang1987stochastic" class="csl-entry" role="listitem">
Wang, Yuchung, and George Wong. 1987. <span>“Stochastic Blockmodels for Directed Graphs.”</span> <em>Journal of the American Statistical Association</em> 82 (397): 8–19.
</div>
<div id="ref-white1983graph" class="csl-entry" role="listitem">
White, Douglas, and Karl Reitz. 1983. <span>“Graph and Semigroup Homomorphisms on Networks of Relations.”</span> <em>Social Networks</em> 5 (2): 193–234.
</div>
<div id="ref-wolff1950sociology" class="csl-entry" role="listitem">
Wolff, Kurt H. 1950. <em>The Sociology of Georg Simmel</em>. Glencoe, Ill: Free Press.
</div>
</div>
</section>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>If you are curious, I suggest consulting this blog post, which does a great job of explaining what Leiden is doing. <a href="https://timoast.github.io/blog/community-detection/">https://timoast.github.io/blog/community-detection/</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./13-social-networks-and-relational-thinking.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Networks: Relationships as Data</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./15-machine-and-statistical-learning.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Machine Learning 101</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>