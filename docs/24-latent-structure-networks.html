<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>24&nbsp; Latent structure in networks – Doing Computational Social Science&lt;br&gt;[The **Continuous Development** Edition]{.small}</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./25-latent-topics-text-lda.html" rel="next">
<link href="./23-causal-analysis.html" rel="prev">
<link href="./figures/logo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./20-linear-regression.html">Generative Modeling</a></li><li class="breadcrumb-item"><a href="./24-latent-structure-networks.html"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Latent structure in networks</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./figures/logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Doing Computational Social Science<br><span class="small">The <strong>Continuous Development</strong> Edition</span></a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/UWNETLAB/dcss_supplementary/tree/master/book/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">👋 Hello!</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Learning to Do Computational Social Science</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Research Computing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-getting-started.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Getting started</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-python-101.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Python 101</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-python-102.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Python 102</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Obtaining Data</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-sampling-and-survey-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Processing Structured Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-web-data-apis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Web data (APIs)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-web-data-scraping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Web data (Scraping)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-audio-image-and-document-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Audio, image, and document data</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Exploring Data</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-exploratory-data-analysis-and-visualization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Exploratory data analysis and visualization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-association-and-latent-factors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Association and latent factors</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-text-as-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Text as Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-text-similarity-and-latent-semantic-space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Text similarity and latent semantic space</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-social-networks-and-relational-thinking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Networks: Relationships as Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-centrality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Centrality</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-structural-similarity-and-latent-social-space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Structural similarity</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Prediction and Inference</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-machine-and-statistical-learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Machine Learning 101</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16-prediction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Prediction</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./17-probability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Probability 101</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./18-credibility.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Credibility</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./19-causality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Causality</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Generative Modeling</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20-linear-regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Bayesian Regression Models with Probabilistic Programming</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./21-multilevel-regression-with-post-stratification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Multilevel regression with post-stratification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./22-generalized-linear-models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Generalized Linear Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./23-causal-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Causal analysis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./24-latent-structure-networks.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Latent structure in networks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./25-latent-topics-text-lda.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Latent topics in text (LDA)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./26-complex-adaptive-systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Agent-based Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./27-developing-agent-based-models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Diffusion</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Deep Learning Demystified</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./28-artificial-neural-networks-fnn-rnn-cnn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Neural networks 101</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./29-processing-natural-language-data-spacy.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Processing Natural Language Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./30-transformers-self-attention.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">30</span>&nbsp; <span class="chapter-title">Transformers, Self-attention architecture</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./31-latent-topics-text-transformers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">31</span>&nbsp; <span class="chapter-title">Modelling latent topics (Transformers)</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Professional Responsibilities</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./32-research-ethics-politics-and-practices.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">32</span>&nbsp; <span class="chapter-title">Research Ethics, Politics, and Practices</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./33-next-steps.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">33</span>&nbsp; <span class="chapter-title">Next steps</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">34</span>&nbsp; <span class="chapter-title">Acknowledgements</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./changelog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">35</span>&nbsp; <span class="chapter-title">Changelog</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appendix-centrality-formulas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Centrality Formulas</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appendix-courses.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Courses and Workshops</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#nested-stochastic-blockmodels-with-graph-tool-enron-email-network" id="toc-nested-stochastic-blockmodels-with-graph-tool-enron-email-network" class="nav-link active" data-scroll-target="#nested-stochastic-blockmodels-with-graph-tool-enron-email-network"><span class="header-section-number">25</span> Nested Stochastic Blockmodels with Graph-Tool (Enron Email Network)</a>
  <ul class="collapse">
  <li><a href="#imports-and-setup" id="toc-imports-and-setup" class="nav-link" data-scroll-target="#imports-and-setup"><span class="header-section-number">25.1</span> Imports and Setup</a></li>
  <li><a href="#load-the-enron-data" id="toc-load-the-enron-data" class="nav-link" data-scroll-target="#load-the-enron-data"><span class="header-section-number">25.2</span> Load the Enron Data</a></li>
  <li><a href="#prepare-for-modelling" id="toc-prepare-for-modelling" class="nav-link" data-scroll-target="#prepare-for-modelling"><span class="header-section-number">25.3</span> Prepare for Modelling</a></li>
  <li><a href="#model-1-a-nested-sbm-with-binary-edges" id="toc-model-1-a-nested-sbm-with-binary-edges" class="nav-link" data-scroll-target="#model-1-a-nested-sbm-with-binary-edges"><span class="header-section-number">25.4</span> Model 1: A Nested SBM with Binary Edges</a></li>
  <li><a href="#model-1-a-nested-sbm-with-binary-edges-1" id="toc-model-1-a-nested-sbm-with-binary-edges-1" class="nav-link" data-scroll-target="#model-1-a-nested-sbm-with-binary-edges-1"><span class="header-section-number">25.5</span> Model 1: A Nested SBM with Binary Edges</a></li>
  <li><a href="#model-1-a-nested-sbm-with-binary-edges-2" id="toc-model-1-a-nested-sbm-with-binary-edges-2" class="nav-link" data-scroll-target="#model-1-a-nested-sbm-with-binary-edges-2"><span class="header-section-number">25.6</span> Model 1: A Nested SBM with Binary Edges</a></li>
  <li><a href="#model-1-a-nested-sbm-with-binary-edges-3" id="toc-model-1-a-nested-sbm-with-binary-edges-3" class="nav-link" data-scroll-target="#model-1-a-nested-sbm-with-binary-edges-3"><span class="header-section-number">25.7</span> Model 1: A Nested SBM with Binary Edges</a></li>
  <li><a href="#model-1-a-nested-sbm-with-binary-edges-4" id="toc-model-1-a-nested-sbm-with-binary-edges-4" class="nav-link" data-scroll-target="#model-1-a-nested-sbm-with-binary-edges-4"><span class="header-section-number">25.8</span> Model 1: A Nested SBM with Binary Edges</a></li>
  <li><a href="#model-2-a-nested-sbm-with-edge-weights" id="toc-model-2-a-nested-sbm-with-edge-weights" class="nav-link" data-scroll-target="#model-2-a-nested-sbm-with-edge-weights"><span class="header-section-number">25.9</span> Model 2: A Nested SBM with Edge Weights</a></li>
  <li><a href="#model-2-a-nested-sbm-with-edge-weights-1" id="toc-model-2-a-nested-sbm-with-edge-weights-1" class="nav-link" data-scroll-target="#model-2-a-nested-sbm-with-edge-weights-1"><span class="header-section-number">25.10</span> Model 2: A Nested SBM with Edge Weights</a></li>
  <li><a href="#model-2-a-nested-sbm-with-edge-weights-2" id="toc-model-2-a-nested-sbm-with-edge-weights-2" class="nav-link" data-scroll-target="#model-2-a-nested-sbm-with-edge-weights-2"><span class="header-section-number">25.11</span> Model 2: A Nested SBM with Edge Weights</a></li>
  <li><a href="#model-2-a-nested-sbm-with-edge-weights-3" id="toc-model-2-a-nested-sbm-with-edge-weights-3" class="nav-link" data-scroll-target="#model-2-a-nested-sbm-with-edge-weights-3"><span class="header-section-number">25.12</span> Model 2: A Nested SBM with Edge Weights</a></li>
  <li><a href="#model-2-a-nested-sbm-with-edge-weights-4" id="toc-model-2-a-nested-sbm-with-edge-weights-4" class="nav-link" data-scroll-target="#model-2-a-nested-sbm-with-edge-weights-4"><span class="header-section-number">25.13</span> Model 2: A Nested SBM with Edge Weights</a></li>
  <li><a href="#model-2-a-nested-sbm-with-edge-weights-5" id="toc-model-2-a-nested-sbm-with-edge-weights-5" class="nav-link" data-scroll-target="#model-2-a-nested-sbm-with-edge-weights-5"><span class="header-section-number">25.14</span> Model 2: A Nested SBM with Edge Weights</a></li>
  <li><a href="#model-3-weighted-poisson-distributed-refined" id="toc-model-3-weighted-poisson-distributed-refined" class="nav-link" data-scroll-target="#model-3-weighted-poisson-distributed-refined"><span class="header-section-number">25.15</span> Model 3: Weighted, Poisson-distributed, Refined</a></li>
  <li><a href="#model-3-weighted-poisson-distributed-refined-1" id="toc-model-3-weighted-poisson-distributed-refined-1" class="nav-link" data-scroll-target="#model-3-weighted-poisson-distributed-refined-1"><span class="header-section-number">25.16</span> Model 3: Weighted, Poisson-distributed, Refined</a></li>
  <li><a href="#posterior-inference" id="toc-posterior-inference" class="nav-link" data-scroll-target="#posterior-inference"><span class="header-section-number">25.17</span> Posterior Inference</a>
  <ul class="collapse">
  <li><a href="#model-4-weighted-poisson-distributed-consensus-partition" id="toc-model-4-weighted-poisson-distributed-consensus-partition" class="nav-link" data-scroll-target="#model-4-weighted-poisson-distributed-consensus-partition"><span class="header-section-number">25.17.1</span> Model 4: Weighted, Poisson-distributed, Consensus Partition</a></li>
  <li><a href="#competing-explanations" id="toc-competing-explanations" class="nav-link" data-scroll-target="#competing-explanations"><span class="header-section-number">25.17.2</span> Competing Explanations?</a></li>
  <li><a href="#competing-explanations-1" id="toc-competing-explanations-1" class="nav-link" data-scroll-target="#competing-explanations-1"><span class="header-section-number">25.17.3</span> Competing Explanations?</a></li>
  <li><a href="#bayesian-hierarchical-stochastic-blockmodels" id="toc-bayesian-hierarchical-stochastic-blockmodels" class="nav-link" data-scroll-target="#bayesian-hierarchical-stochastic-blockmodels"><span class="header-section-number">25.17.4</span> Bayesian Hierarchical Stochastic Blockmodels</a></li>
  </ul></li>
  <li><a href="#blockmodelling-with-graph-tool" id="toc-blockmodelling-with-graph-tool" class="nav-link" data-scroll-target="#blockmodelling-with-graph-tool"><span class="header-section-number">25.18</span> BLOCKMODELLING WITH GRAPH-TOOL</a>
  <ul class="collapse">
  <li><a href="#installing-graph-tool" id="toc-installing-graph-tool" class="nav-link" data-scroll-target="#installing-graph-tool"><span class="header-section-number">25.18.1</span> Installing graph-tool</a></li>
  <li><a href="#understanding-property-maps" id="toc-understanding-property-maps" class="nav-link" data-scroll-target="#understanding-property-maps"><span class="header-section-number">25.18.2</span> Understanding Property Maps</a></li>
  <li><a href="#imports" id="toc-imports" class="nav-link" data-scroll-target="#imports"><span class="header-section-number">25.18.3</span> Imports</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data"><span class="header-section-number">25.18.4</span> Data</a></li>
  <li><a href="#developing-stochastic-blockmodels" id="toc-developing-stochastic-blockmodels" class="nav-link" data-scroll-target="#developing-stochastic-blockmodels"><span class="header-section-number">25.18.5</span> Developing Stochastic Blockmodels</a></li>
  <li><a href="#model-selection-and-optimization" id="toc-model-selection-and-optimization" class="nav-link" data-scroll-target="#model-selection-and-optimization"><span class="header-section-number">25.18.6</span> Model Selection and Optimization</a></li>
  <li><a href="#more-mcmc" id="toc-more-mcmc" class="nav-link" data-scroll-target="#more-mcmc"><span class="header-section-number">25.18.7</span> More MCMC</a></li>
  <li><a href="#visualizing-block-connections-as-a-radial-tree" id="toc-visualizing-block-connections-as-a-radial-tree" class="nav-link" data-scroll-target="#visualizing-block-connections-as-a-radial-tree"><span class="header-section-number">25.18.8</span> Visualizing Block Connections as a Radial Tree</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">25.19</span> CONCLUSION</a>
  <ul class="collapse">
  <li><a href="#key-points" id="toc-key-points" class="nav-link" data-scroll-target="#key-points"><span class="header-section-number">25.19.1</span> Key Points</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/UWNETLAB/dcss_supplementary/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./20-linear-regression.html">Generative Modeling</a></li><li class="breadcrumb-item"><a href="./24-latent-structure-networks.html"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Latent structure in networks</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Latent structure in networks</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<ul>
<li><strong>TODO</strong>: The old NSBM content is appended to the end. Merge these, etc.</li>
</ul>
<!-- Nested Stochastic Blockmodels -->
<blockquote class="blockquote">
<p>Fold in relevant content from _generative-network-analysis-with-bayesian-stochastic-blockmodels.qmd</p>
</blockquote>
<section id="nested-stochastic-blockmodels-with-graph-tool-enron-email-network" class="level1" data-number="25">
<h1 data-number="25"><span class="header-section-number">25</span> Nested Stochastic Blockmodels with Graph-Tool (Enron Email Network)</h1>
<p>In this tutorial, you’ll learn how to use <code>graph-tool</code> to iteratively fit, improve, and compare Nested Stochastic Blockmodels (NSBMs) by analyzing a directed email communication network between Enron employees. You also learn how to conduct rigorous posterior inference about the network from a generative modelling perspective.</p>
<p>The models we’ll develop here start simple and gradually increase in complexity, incorporating additional information about the Enron network, or applying refinements to better estimate it’s structure. We will visualize, assess, and compare these models, and finally, analyze the posterior distribution of block partitions to quantify uncertainty, compute marginal probabilities for node block assignments, and determine if there are other plausible explanations for the structure of our observed network.</p>
<p>This will be a bit of a modelling marathon, so if all of this is new to you, <em>focus on high-level logic</em>. Whether this is new to you or not, it will take a while for this content to really sink it. Give it time, take breaks, and come back to this material as often as you need to.</p>
<p>Below, we’ll use <code>graph-tool</code> to:</p>
<ul>
<li>iteratively fit, improve, and compare Nested Stochastic Blockmodels by analyzing a directed email communication network between Enron employees</li>
<li>conduct rigorous posterior inference about the network from a generative modelling perspective</li>
</ul>
<section id="imports-and-setup" class="level2" data-number="25.1">
<h2 data-number="25.1" class="anchored" data-anchor-id="imports-and-setup"><span class="header-section-number">25.1</span> Imports and Setup</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pickle</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pprint <span class="im">import</span> pprint</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> graph_tool.<span class="bu">all</span> <span class="im">as</span> gt</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> ticker</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> homogeneity_score</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> icsspy</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> icsspy.networks <span class="im">import</span> (</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    get_consensus_partition_from_posterior,</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    plot_line_comparison,</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> icsspy.paths <span class="im">import</span> enron</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>icsspy.set_style()</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Using graph-tool version </span><span class="sc">{</span>gt<span class="sc">.</span>__version__<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="load-the-enron-data" class="level2" data-number="25.2">
<h2 data-number="25.2" class="anchored" data-anchor-id="load-the-enron-data"><span class="header-section-number">25.2</span> Load the Enron Data</h2>
<p>We can load the Enron email data <span class="citation" data-cites="crick2022enron">(<a href="references.html#ref-crick2022enron" role="doc-biblioref"><strong>crick2022enron?</strong></a>)</span> from the <code>icsspy</code> course package. The network itself has already been prepared and can be loaded directly into <code>graph-tool</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>enron_email_network <span class="op">=</span> <span class="bu">str</span>(enron <span class="op">/</span> <span class="st">'enron_graph.gt'</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> gt.load_graph(enron_email_network)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Like the political blogs network, this network has internal property maps containing data about node and edge attributes, as well as the graph itself. We can list the available property maps:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>g.list_properties()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>label</code> is a string variable containing the email address.</li>
<li><code>position</code> is a string variable containing information about the job position associated with the email account.</li>
<li><code>edge weight</code> are counts of the number of emails that vertex <span class="math inline">\(i\)</span> sent vertex <span class="math inline">\(j\)</span> (since this is a directed network).</li>
</ul>
</section>
<section id="prepare-for-modelling" class="level2" data-number="25.3">
<h2 data-number="25.3" class="anchored" data-anchor-id="prepare-for-modelling"><span class="header-section-number">25.3</span> Prepare for Modelling</h2>
<p>Since we’ll be creating a series of identical visualizations for each model, let’s define a simple visualization function so we can avoid repeating ourselves. <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">☂︎</a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> draw_state(state, g, hvprops, heprops, filename<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    state.draw(</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        vertex_text <span class="op">=</span> g.vp[<span class="st">'position'</span>],</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        hvprops<span class="op">=</span>hvprops,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        heprops<span class="op">=</span>heprops,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        vertex_size<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        output_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">1200</span>),</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        bg_color<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        output<span class="op">=</span>filename,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll also initialize a couple of empty dictionaries that we’ll use to collect information about our models once they’ve been fit. The first will store each model’s Minimum Description Length (MDL), the second will store homogeneity scores.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>model_mdl_scores <span class="op">=</span> {}</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>model_homogeneity_scores <span class="op">=</span> {}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="model-1-a-nested-sbm-with-binary-edges" class="level2" data-number="25.4">
<h2 data-number="25.4" class="anchored" data-anchor-id="model-1-a-nested-sbm-with-binary-edges"><span class="header-section-number">25.4</span> Model 1: A Nested SBM with Binary Edges</h2>
<p>As before, let’s start with a simple nested SBM and visualization. We’ll use <code>gt.minimize_nested_blockmodel_dl()</code> with the default parameters, which is the same default nested SBM we fit in our analysis of the political blogs networks in the previous notebook. This model will select the best fitting posterior partition, where “best fitting” means the posterior partition with the shortest Minimum Description Length (MDL).</p>
<p>Since we have not passed an argument for edge weights, the model will treat this network as binary; the only information we are using to estimate the latent hierarchical block structure of this network is the presence or absence of edges.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>model_1 <span class="op">=</span> gt.minimize_nested_blockmodel_dl(g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now that we’ve fit the model, let’s visualize the results.</p>
</section>
<section id="model-1-a-nested-sbm-with-binary-edges-1" class="level2" data-number="25.5">
<h2 data-number="25.5" class="anchored" data-anchor-id="model-1-a-nested-sbm-with-binary-edges-1"><span class="header-section-number">25.5</span> Model 1: A Nested SBM with Binary Edges</h2>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>hvprops <span class="op">=</span> {<span class="st">"fill_color"</span>: <span class="st">"black"</span>, <span class="st">"size"</span>: <span class="dv">30</span>}</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>heprops <span class="op">=</span> {<span class="st">"color"</span>: <span class="st">"black"</span>, <span class="st">"pen_width"</span>: <span class="dv">2</span>}</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>draw_state(state<span class="op">=</span>model_1, g<span class="op">=</span>g, hvprops<span class="op">=</span>hvprops, heprops<span class="op">=</span>heprops)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This visualization conveys a lot of information about the estimated network structure. Each node’s job title is printed on the node (although you’ll really have to squint to read it). You may notice that some blocks contain clusters of folks with the same or similar job titles. This makes some intuitive sense, especially when considered in terms of <strong>positional network analysis</strong> and the concept of <strong>stochastic equivalence</strong>. It’s plausible, likely even, that the formal roles people hold in the organization generate different relational patterns, however noisy, and that these patterns would be picked up by the blockmodel.</p>
</section>
<section id="model-1-a-nested-sbm-with-binary-edges-2" class="level2" data-number="25.6">
<h2 data-number="25.6" class="anchored" data-anchor-id="model-1-a-nested-sbm-with-binary-edges-2"><span class="header-section-number">25.6</span> Model 1: A Nested SBM with Binary Edges</h2>
<p>To get a better sense of how homogeneous blocks are with respect to job titles, we can get the position labels from our internal property map <code>position</code> and compute a homogeneity score for the combination of job positions and block membership. To do so, we’ll iterate over the vertices in the graph and collect the information we need from the appropriate property maps.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>m1_l0_prop_map <span class="op">=</span> model_1.levels[<span class="dv">0</span>].b <span class="co"># block assignment property map</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>vertex_data <span class="op">=</span> []</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> g.vertices():</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    vertex_data.append((<span class="bu">int</span>(v), g.vp.position[v], m1_l0_prop_map[v]))</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>vertex_data <span class="op">=</span> pd.DataFrame(vertex_data)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>vertex_data.columns <span class="op">=</span> [<span class="st">"VertexID"</span>, <span class="st">"JobPosition"</span>, <span class="st">"M1BlockID"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="model-1-a-nested-sbm-with-binary-edges-3" class="level2" data-number="25.7">
<h2 data-number="25.7" class="anchored" data-anchor-id="model-1-a-nested-sbm-with-binary-edges-3"><span class="header-section-number">25.7</span> Model 1: A Nested SBM with Binary Edges</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>vertex_data.head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="model-1-a-nested-sbm-with-binary-edges-4" class="level2" data-number="25.8">
<h2 data-number="25.8" class="anchored" data-anchor-id="model-1-a-nested-sbm-with-binary-edges-4"><span class="header-section-number">25.8</span> Model 1: A Nested SBM with Binary Edges</h2>
<p>We’ll use <code>sklearn</code>’s homogeneity score to calculate the uncertainty (via entropy) of the job positions within each block ID. The closer the score is to 1, the more homogeneous the blocks are with respect to job titles.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>m1_homogeneity <span class="op">=</span> homogeneity_score(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    vertex_data[<span class="st">'JobPosition'</span>], vertex_data[<span class="st">'M1BlockID'</span>]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>model_homogeneity_scores[<span class="st">'Model 1'</span>] <span class="op">=</span> <span class="bu">round</span>(<span class="bu">float</span>(m1_homogeneity), <span class="dv">4</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>pprint(model_homogeneity_scores)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Remember, this is not supervised learning! We are not <em>trying</em> to group nodes based on their job titles, we are just hypothesizing that at least some of the network structure is driven by the formal roles people in the network hold. In that sense, the score doesn’t tell us anything about how good or bad our model is, but once we’ve fit a few more models we can compare homogeneity scores to see whether some models result in more homogeneous blocks than others, and whether patterns show up across models.</p>
</section>
<section id="model-2-a-nested-sbm-with-edge-weights" class="level2" data-number="25.9">
<h2 data-number="25.9" class="anchored" data-anchor-id="model-2-a-nested-sbm-with-edge-weights"><span class="header-section-number">25.9</span> Model 2: A Nested SBM with Edge Weights</h2>
<p>We fit Model 1 using binary edges. In Model 2, we’ll complicate things a wee bit by including edge weights, which are counts. Before we model our edges, let’s get an initial sense of how they are distributed by plotting them as an <a href="https://en.wikipedia.org/wiki/Empirical_distribution_function">ECDF</a> (basically a cumulative histogram).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>sns.ecdfplot(g.ep.edge_weight.a)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"</span><span class="ch">\n</span><span class="st">No. of emails sent from $i$ to $j$"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Proportion of edges</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"EDCF of edge weights</span><span class="ch">\n</span><span class="st">in the Enron email network</span><span class="ch">\n</span><span class="st">"</span>, loc<span class="op">=</span><span class="st">"left"</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>plt.gca().xaxis.set_major_formatter(ticker.FuncFormatter(<span class="kw">lambda</span> x, _: <span class="ss">f'</span><span class="sc">{</span><span class="bu">int</span>(x)<span class="sc">:,}</span><span class="ss">'</span>)) <span class="co"># comma format the x-axis</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'output/enron_edge_weight_ecdf.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="model-2-a-nested-sbm-with-edge-weights-1" class="level2" data-number="25.10">
<h2 data-number="25.10" class="anchored" data-anchor-id="model-2-a-nested-sbm-with-edge-weights-1"><span class="header-section-number">25.10</span> Model 2: A Nested SBM with Edge Weights</h2>
<p>In the SBM framework, we can include edge weights as covariates in our generative model and assume that they are sampled from some probability distribution conditioned on the block partitions (i.e., a <strong>prior distribution</strong>).</p>
<p>Given that this data is over-dispersed (i.e., the variance is greater than the mean), a <a href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">Negative Binomial distribution</a> would be an appropriate choice to model these edges, but as of fall 2024 <a href="https://graph-tool.skewed.de/static/doc/demos/inference/inference.html#edge-weights-and-covariates">it is not implemented in <code>graph-tool</code></a>. While we can extend the distributions available in <code>graph-tool</code> by applying transformations,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> we’ll keep things relatively simple here by modelling the edges with a <a href="https://en.wikipedia.org/wiki/Poisson_distribution">Poisson distribution</a>. This should still provide a reasonable approximation, though it may not do the best job of characterizing the heavy tail of the distribution. Be mindful of this model limitation!</p>
</section>
<section id="model-2-a-nested-sbm-with-edge-weights-2" class="level2" data-number="25.11">
<h2 data-number="25.11" class="anchored" data-anchor-id="model-2-a-nested-sbm-with-edge-weights-2"><span class="header-section-number">25.11</span> Model 2: A Nested SBM with Edge Weights</h2>
<p>We’ll use the <code>minimize_nested_blockmodel_dl()</code> function again to fit Model 2, but this time we’ll add an argument called <code>state_args</code>. <code>state_args</code> contains two important pieces of information:</p>
<ul>
<li>the edge weight property map, passed to <code>recs</code>, and</li>
<li>the probability distribution we want to use to model the edge weights, passed to <code>rec_types</code>.</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>model_2 <span class="op">=</span> gt.minimize_nested_blockmodel_dl(</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    g,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    state_args <span class="op">=</span> <span class="bu">dict</span>(</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        recs<span class="op">=</span>[g.ep.edge_weight],</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        rec_types <span class="op">=</span> [<span class="st">'discrete-poisson'</span>]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As we did with Model 1, let’s plot the network’s hierarchical block structure (using the same <code>hvprops</code> and <code>heprops</code> customization for our <code>draw_state()</code> function).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>draw_state(model_2, g, hvprops, heprops)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll also add the new block assignments to the <code>vertex_data</code> dataframe we created above.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>m2_l0_prop_map <span class="op">=</span> model_2.levels[<span class="dv">0</span>].b  <span class="co"># block assignment property map</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>m2_vertex_data <span class="op">=</span> {}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> g.vertices():</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    m2_vertex_data[<span class="bu">int</span>(v)] <span class="op">=</span> m2_l0_prop_map[v]</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>vertex_data[<span class="st">'M2BlockID'</span>] <span class="op">=</span> vertex_data[<span class="st">'VertexID'</span>].<span class="bu">map</span>(m2_vertex_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Remember that the integer block IDs are just labels; they aren’t meaningful in any numerical sense. The labels that get assigned depend on the model itself, so it doesn’t mean anything if a new model puts a node in a block with a different integer label. It may be the case that the node has been assigned to a different block, but the labels do not tell us if that is the case.</p>
<section id="mdl-and-homogeneity" class="level4" data-number="25.11.0.1">
<h4 data-number="25.11.0.1" class="anchored" data-anchor-id="mdl-and-homogeneity"><span class="header-section-number">25.11.0.1</span> MDL and Homogeneity</h4>
<p>Visually (<span class="quarto-unresolved-ref">?fig-enron_model_2</span>) we can already see that the inclusion of edge weights has changed the model’s best estimate of the latent block structure. What did it do the MDL?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>m2_mdl <span class="op">=</span> model_2.entropy()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>model_mdl_scores[<span class="st">"Model 2"</span>] <span class="op">=</span> <span class="bu">int</span>(<span class="bu">round</span>(m2_mdl))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>pprint(model_mdl_scores)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The MDL score is much higher! However, <em>this is to be expected</em>, as the jump from a binary to a weighted network requires a huge increase in bits to adequately compress the network. We’ll see how this model compares to the other weighted models we’ll fit below.</p>
<p>MDL is Always Larger for Models with Edge Weights and Other Covariates</p>
<p>Recall that MDL is computed by compressing the model <em>and</em> the data. Models with more parameters will always have larger MDLs, and models with edge weights always have more parameters than binary networks. Weighted networks contain more information than binary networks, and therefore require more bits to compress.</p>
<p>Although MDL is a model-agnostic way of comparing model fits, this doesn’t mean that the models using binary edges are to be preferred over weighted networks. We want to strike a good balance between having simple parsimonious models on the one hand and models that are complex enough to adequately explain our data on the other hand. This will often mean that, given the choice, we’ll want to a select models with the lowest MDL given a set of models that sufficiently capture our network, and it may be that models of binary networks are not considered sufficient when compared to their weighted counterparts. This is a matter of judgement.</p>
</section>
</section>
<section id="model-2-a-nested-sbm-with-edge-weights-3" class="level2" data-number="25.12">
<h2 data-number="25.12" class="anchored" data-anchor-id="model-2-a-nested-sbm-with-edge-weights-3"><span class="header-section-number">25.12</span> Model 2: A Nested SBM with Edge Weights</h2>
<p>Let’s plot the MDLs for the models we’ve fit so far for easy comparison (<span class="quarto-unresolved-ref">?fig-model_comparison_mdl_M1_M2</span>). We’ll use the <code>plot_line_comparison()</code> function from the <code>icsspy</code> course package.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>plot_line_comparison(</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    models_dict<span class="op">=</span>model_mdl_scores,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Model Comparison</span><span class="ch">\n</span><span class="st">Minimum Description Length (MDL)</span><span class="ch">\n</span><span class="st">"</span>,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    xlabel<span class="op">=</span><span class="st">"</span><span class="ch">\n</span><span class="st">MDL"</span>,</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    padding<span class="op">=</span><span class="dv">5_000</span>,</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    filename <span class="op">=</span> <span class="st">'output/model_comparison_mdl_M1_M2.png'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="model-2-a-nested-sbm-with-edge-weights-4" class="level2" data-number="25.13">
<h2 data-number="25.13" class="anchored" data-anchor-id="model-2-a-nested-sbm-with-edge-weights-4"><span class="header-section-number">25.13</span> Model 2: A Nested SBM with Edge Weights</h2>
<p>What about the homogeneity of job titles within blocks?</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>m2_homogeneity <span class="op">=</span> homogeneity_score(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    vertex_data[<span class="st">'JobPosition'</span>], vertex_data[<span class="st">'M2BlockID'</span>]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>model_homogeneity_scores[<span class="st">'Model 2'</span>] <span class="op">=</span> <span class="bu">round</span>(<span class="bu">float</span>(m2_homogeneity), <span class="dv">4</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>pprint(model_homogeneity_scores)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When we model edge weights rather than just presence/absence, the best posterior partition aligns more closely with the formal job descriptions themselves.</p>
</section>
<section id="model-2-a-nested-sbm-with-edge-weights-5" class="level2" data-number="25.14">
<h2 data-number="25.14" class="anchored" data-anchor-id="model-2-a-nested-sbm-with-edge-weights-5"><span class="header-section-number">25.14</span> Model 2: A Nested SBM with Edge Weights</h2>
<p>Let’s plot these as well.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>plot_line_comparison(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    models_dict<span class="op">=</span>model_homogeneity_scores,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Model Comparison</span><span class="ch">\n</span><span class="st">Block homogeneity wrt formal job titles</span><span class="ch">\n</span><span class="st">"</span>,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    xlabel<span class="op">=</span><span class="st">"</span><span class="ch">\n</span><span class="st">Homogeneity"</span>,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">xrange</span><span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>),  <span class="co"># homogeneity scores range from 0 to 1</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    print_decimals<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    filename <span class="op">=</span> <span class="st">'output/model_comparison_homogeneity_M1_M2.png'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="model-3-weighted-poisson-distributed-refined" class="level2" data-number="25.15">
<h2 data-number="25.15" class="anchored" data-anchor-id="model-3-weighted-poisson-distributed-refined"><span class="header-section-number">25.15</span> Model 3: Weighted, Poisson-distributed, Refined</h2>
<p>Once again, we are modelling our edges as Poisson-distributed. The difference between Models 2 and 3 is that Model 3 includes some additional <strong>r</strong>efinements on the partition we found with Model 2. Let’s take a moment to understand what this means.</p>
<section id="why-refine-nested-sbms" class="level4" data-number="25.15.0.1">
<h4 data-number="25.15.0.1" class="anchored" data-anchor-id="why-refine-nested-sbms"><span class="header-section-number">25.15.0.1</span> Why Refine Nested SBMs?</h4>
<p>Minimizing a model’s description length is equivalent to maximizing it’s posterior probability. In theory, when we find a good partition with minimal description length, we’ve also found the partition with maximum posterior probability. But this isn’t always the case, as our search space – the posterior distribution of all possible partitions – is vast and complex. It’s possible that the partition we find with <code>minimize_nested_blockmodel_dl()</code> came from a local minima rather than the global minima. If it came from a local minima, it may be very good but not the best.</p>
<p>To improve out estimates, we’ll further explore the posterior distribution, enough to escape any local minima and to find the global minima. This involves making iterative refinements using Markov Chain Monte Carlo (MCMC) sampling. We sample from our posterior distribution to find partitions that further lower MDL and maximize posterior probability. This process <em>starts</em> with our initial partition, rather than randomly, which makes the MCMC sampling process in <code>graph-tool</code> very efficient.</p>
<p>In short, you can think of the initial partition returned from the <code>minimize_nested_blockmodel_dl()</code> function as the best guess about the best partition, and the refined estimate as the best partition,<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> identified by more thoroughly exploring the posterior distribution.</p>
<p>How do we do this in <code>graph-tool</code>? In short, we want to run a merge-split MCMC refinement algorithm multiple times, each time storing the resulting blockstates and description lengths. At the end, we select the model with the shortest description length. Let’s fit Model 3!</p>
</section>
</section>
<section id="model-3-weighted-poisson-distributed-refined-1" class="level2" data-number="25.16">
<h2 data-number="25.16" class="anchored" data-anchor-id="model-3-weighted-poisson-distributed-refined-1"><span class="header-section-number">25.16</span> Model 3: Weighted, Poisson-distributed, Refined</h2>
<p>Since this model is a refinement of Model 2, we use Model 2 as a base and accept new partitions only if they have shorter description lengths than the Model 2 partition.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>model_3 <span class="op">=</span> model_2.copy() <span class="co"># will update if there are improvements to be had</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>m3_mdl <span class="op">=</span> model_2.entropy()</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>num_refinements <span class="op">=</span> <span class="dv">10</span> <span class="co"># no. of times to refine the initial state using merge-split MCMC</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>num_mcmc_calls <span class="op">=</span> <span class="dv">2_000</span> <span class="co"># no. of times to call multiflip_mcmc_sweep within a refinement loop</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>num_mcmc_iters_per_call <span class="op">=</span> <span class="dv">10</span> <span class="co"># no. iterations to perform per single multiflip_mcmc_sweep call</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_refinements):</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    temp_state <span class="op">=</span> model_2.copy()</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_mcmc_calls):</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        temp_state.multiflip_mcmc_sweep(beta<span class="op">=</span>np.inf, niter<span class="op">=</span>num_mcmc_iters_per_call)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> temp_state.entropy() <span class="op">&lt;</span> m3_mdl:</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        model_3 <span class="op">=</span> temp_state</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        m3_mdl <span class="op">=</span> temp_state.entropy()</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co"># draw the model</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>draw_state(state<span class="op">=</span>model_3, g<span class="op">=</span>g, hvprops<span class="op">=</span>hvprops, heprops<span class="op">=</span>heprops)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That code block will take a while to run. As you wait for it to finish, let’s unpack the code a bit. Above, we set three variables that have a massive impact on how extensively we search the posterior distribution: <code>num_refinements</code>, <code>num_mcmc_calls</code>, and <code>num_mcmc_iters_per_call</code>. Let’s break down what each of these are, and how they work together to influence our search.</p>
<p>The first parameter, <code>num_refinements</code>, represents the number of separate searches of the posterior distribution we will conduct. Each starts from the same initial state – Model 2! – but is independent from the other searches. By performing a number of independent searches, in this case {{ num_refinements }}, we make it much less likely that our final result comes from a local minima.</p>
<p>The second, <code>num_mcmc_calls</code>, determines the number of times we call the <code>multiflip_mcmc_sweep()</code> function within a single refinement loop. If we set to <code>10_000</code>, each refinement loop will execute <code>multiflip_mcmc_sweep()</code> 10,000 times, and hence will explore more of the parameter space. Once again, this increases the chances of finding improvements for our partition.</p>
<p>Finally, <code>num_mcmc_iters_per_call</code> determines the number of iterations that <code>multiflip_mcmc_sweep()</code> performs in each individual call. Each iteration attempts to refine the current partition by proposing changes to the MCMC algorithm, and then either accepting or rejecting the change. When we increase this number, we again search the posterior distribution more thoroughly, increasing the chances of improving our partition.</p>
<p>How thoroughly we search the posterior distribution depends on all three of these parameters. The larger the numbers we provide our three search parameters, the more thoroughly we search the posterior distribution, and the more likely we are to find refinements for our model. The cost, of course, is increased computation time.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>m3_l0_prop_map <span class="op">=</span> model_3.levels[<span class="dv">0</span>].b  <span class="co"># block assignment property map</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>m3_vertex_data <span class="op">=</span> {}</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> g.vertices():</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    m3_vertex_data[<span class="bu">int</span>(v)] <span class="op">=</span> m3_l0_prop_map[v]</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>vertex_data[<span class="st">'M3BlockID'</span>] <span class="op">=</span> vertex_data[<span class="st">'VertexID'</span>].<span class="bu">map</span>(m3_vertex_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>How does Model 3 compare to Models 1 and 2?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>model_mdl_scores[<span class="st">"Model 3"</span>] <span class="op">=</span> <span class="bu">int</span>(<span class="bu">round</span>(m3_mdl))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>pprint(model_mdl_scores)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>plot_line_comparison(</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    models_dict<span class="op">=</span>model_mdl_scores,</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Model Comparison</span><span class="ch">\n</span><span class="st">Minimum Description Length (MDL)</span><span class="ch">\n</span><span class="st">"</span>,</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    xlabel<span class="op">=</span><span class="st">"</span><span class="ch">\n</span><span class="st">MDL"</span>,</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    padding<span class="op">=</span><span class="dv">5_000</span>,</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    filename <span class="op">=</span> <span class="st">'output/model_comparison_mdl_M1_M2_M3.png'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>m3_homogeneity <span class="op">=</span> homogeneity_score(</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    vertex_data[<span class="st">'JobPosition'</span>], vertex_data[<span class="st">'M3BlockID'</span>]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>model_homogeneity_scores[<span class="st">'Model 3'</span>] <span class="op">=</span> <span class="bu">round</span>(<span class="bu">float</span>(m3_homogeneity), <span class="dv">4</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>pprint(model_homogeneity_scores)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>plot_line_comparison(</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    models_dict<span class="op">=</span>model_homogeneity_scores,</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Model Comparison</span><span class="ch">\n</span><span class="st">Block homogeneity wrt formal job titles</span><span class="ch">\n</span><span class="st">"</span>,</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    xlabel<span class="op">=</span><span class="st">"</span><span class="ch">\n</span><span class="st">Homogeneity"</span>,</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">xrange</span><span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    print_decimals<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    filename <span class="op">=</span> <span class="st">'output/model_comparison_homogeneity_M1_M2_M3.png'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="posterior-inference" class="level2" data-number="25.17">
<h2 data-number="25.17" class="anchored" data-anchor-id="posterior-inference"><span class="header-section-number">25.17</span> Posterior Inference</h2>
<p>In this next section of the notebook, we’ll do two things that require more intensive analysis of the posterior distribution of block partitions.</p>
<p><strong>First</strong>, we’ll develop another Nested SBM that creates a “consensus partition” by averaging over a large sample of partitions from the posterior distribution, weighted by their posterior probabilities. This quantifies uncertainties in the blockmodelling process, including determining the number of blocks at each level, and block membership at each level (i.e.&nbsp;the block assignment marginal probabilities).</p>
<p><strong>Second</strong>, we’ll perform some additional analyses of the posterior distribution with the goal of figuring out whether it contains other high-probability partitions that could represent plausible competing explanations, or “data stories,” for the network structure we’ve observed.</p>
<section id="model-4-weighted-poisson-distributed-consensus-partition" class="level3" data-number="25.17.1">
<h3 data-number="25.17.1" class="anchored" data-anchor-id="model-4-weighted-poisson-distributed-consensus-partition"><span class="header-section-number">25.17.1</span> Model 4: Weighted, Poisson-distributed, Consensus Partition</h3>
<p>In Model 3, we refined the partition from Model 2 by more thoroughly searching the posterior distribution of partitions. Those refinements are <em>optimizations</em> of the Model 2 partition. In other words, we searched the posterior distribution for ways to improve our best guess about the best partition. We can improve our analysis even further by <strong>averaging over many posterior partitions</strong>, weighted by their posterior probabilities, rather than attempting to find the single best fitting partition. This quantifies uncertainty in our node-level block assignments and accounts for variability across many different but plausible partitions. We can use <code>get_consensus_partition_from_posterior</code> from the course package to simplify this process.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>model_4 <span class="op">=</span> get_consensus_partition_from_posterior(model_3, g, force_niter<span class="op">=</span><span class="dv">2000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s take a look at our model’s MDL, and compare it to Models 1-3.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>m4_mdl <span class="op">=</span> model_4.entropy()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>model_mdl_scores[<span class="st">"Model 4"</span>] <span class="op">=</span> <span class="bu">int</span>(<span class="bu">round</span>(m4_mdl))</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>plot_line_comparison(</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    models_dict<span class="op">=</span>model_mdl_scores,</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Model Comparison</span><span class="ch">\n</span><span class="st">Minimum Description Length (MDL)</span><span class="ch">\n</span><span class="st">"</span>,</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    xlabel<span class="op">=</span><span class="st">"</span><span class="ch">\n</span><span class="st">MDL"</span>,</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    padding<span class="op">=</span><span class="dv">10_000</span>,</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    filename <span class="op">=</span> <span class="st">'output/model_comparison_mdl_M1_M2_M3_M4.png'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>get_consensus_partition_from_posterior()</code> function assigns each node to a block in the consensus partition (averages from partitions in the posterior weighted by posterior probability). We can extract that block information to consider homogeneity with respect to job titles for this model (below).</p>
<p>As we go through the usual process below, we’ll also extract information from a newly created internal property map that contains counts the times each node was assigned to each partition in our posterior samples. We can normalize these counts to get the each node’s marginal probability for it’s block assignment. We’ll store that information in our <code>vertex_data</code> dataframe as well and will look at it shortly.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>m4_l0_prop_map <span class="op">=</span> model_4.levels[<span class="dv">0</span>].b</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>marginal_counts_consensus_partition <span class="op">=</span> g.vertex_properties[<span class="st">"pv"</span>]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>m4_vertex_assignments <span class="op">=</span> {}</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>m4_vertex_marginal_probs <span class="op">=</span> {}</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> g.vertices():</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    assigned_block <span class="op">=</span> m4_l0_prop_map[v]</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    m4_vertex_assignments[<span class="bu">int</span>(v)] <span class="op">=</span> assigned_block</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># get the count for the assigned block</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    count_of_assigned_block <span class="op">=</span> marginal_counts_consensus_partition[v][assigned_block]</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># normalize the count to get the probability</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    total_count <span class="op">=</span> <span class="bu">sum</span>(marginal_counts_consensus_partition[v])</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    prob_of_assigned_block <span class="op">=</span> count_of_assigned_block <span class="op">/</span> total_count</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    m4_vertex_marginal_probs[<span class="bu">int</span>(v)] <span class="op">=</span> prob_of_assigned_block</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>vertex_data[<span class="st">'M4BlockID'</span>] <span class="op">=</span> vertex_data[<span class="st">'VertexID'</span>].<span class="bu">map</span>(m4_vertex_assignments)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>vertex_data[<span class="st">'MargProbsConsPart'</span>] <span class="op">=</span> vertex_data[<span class="st">'VertexID'</span>].<span class="bu">map</span>(m4_vertex_marginal_probs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>What do our homogeneity look like now, using the consensus partition?</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>m4_homogeneity <span class="op">=</span> homogeneity_score(</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    vertex_data[<span class="st">'JobPosition'</span>], vertex_data[<span class="st">'M4BlockID'</span>]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>model_homogeneity_scores[<span class="st">'Model 4'</span>] <span class="op">=</span> <span class="bu">round</span>(<span class="bu">float</span>(m4_homogeneity), <span class="dv">4</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>plot_line_comparison(</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    models_dict<span class="op">=</span>model_homogeneity_scores,</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Model Comparison</span><span class="ch">\n</span><span class="st">Block homogeneity wrt formal job titles</span><span class="ch">\n</span><span class="st">"</span>,</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    xlabel<span class="op">=</span><span class="st">"</span><span class="ch">\n</span><span class="st">Homogeneity"</span>,</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">xrange</span><span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    print_decimals<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    filename <span class="op">=</span> <span class="st">'output/model_comparison_homogeneity_M1_M2_M3_M4.png'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can also use the <code>pv</code> property map to change the appearance of the nodes in our visualizations to fractions of a pie, reflecting the marginal probabilities of block assignments. We won’t use our <code>draw_state()</code> function this time, since we’re using some new arguments that we didn’t include in that function: <code>vertex_shape</code> and <code>vertex_pie_fractions</code>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>hvprops[<span class="st">'size'</span>] <span class="op">=</span> <span class="dv">15</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>model_4.draw(</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    vertex_shape<span class="op">=</span><span class="st">"pie"</span>,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    vertex_pie_fractions<span class="op">=</span>g.vp[<span class="st">'pv'</span>],</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    hvprops<span class="op">=</span>hvprops,</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    heprops<span class="op">=</span>heprops,</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="competing-explanations" class="level3" data-number="25.17.2">
<h3 data-number="25.17.2" class="anchored" data-anchor-id="competing-explanations"><span class="header-section-number">25.17.2</span> Competing Explanations?</h3>
<p>When developing generative models, the posterior distribution may contain multiple explanations of the network structure with nearly equal probability. This is exactly why Bayesian generative modelling emphasizes analysis of the <em>full</em> posterior distribution rather than selecting a single best estimate.</p>
<p>In the case of SBMs, even when we create a consensus partition from the posterior, we may still want to know whether the posterior contains clusters of similar partitions that differ from the one we selected, but which are still very plausible. Each these different partitions may be offering different generative explanations of the observed network, which is definitely something we would want to know!</p>
<p>To determine whether this is the case, we can infer the modes of the posterior distribution to identify clusters of graph partitions that are similar to one another but different from those in other clusters (see <a href="https://journals.aps.org/prx/pdf/10.1103/PhysRevX.11.021003">Peixoto (2021)</a>).</p>
</section>
<section id="competing-explanations-1" class="level3" data-number="25.17.3">
<h3 data-number="25.17.3" class="anchored" data-anchor-id="competing-explanations-1"><span class="header-section-number">25.17.3</span> Competing Explanations?</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>n_partitions_sample <span class="op">=</span> <span class="dv">5000</span> <span class="co"># the larger the number, the more accurate the estimates</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> gt.NestedBlockState(g) <span class="co"># initialize</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>gt.mcmc_equilibrate(state,</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    force_niter<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    mcmc_args<span class="op">=</span><span class="bu">dict</span>(niter<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>bs <span class="op">=</span> []</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> collect_partitions(s):</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>   <span class="kw">global</span> bs</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>   bs.append(s.get_bs())</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>gt.mcmc_equilibrate(state,</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    force_niter<span class="op">=</span>n_partitions_sample,</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    mcmc_args<span class="op">=</span><span class="bu">dict</span>(niter<span class="op">=</span><span class="dv">10</span>),</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    callback<span class="op">=</span>collect_partitions</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="co"># infer partition modes in posterior</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>pmode <span class="op">=</span> gt.ModeClusterState(bs, nested<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="co"># minimize the mode state itself</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>gt.mcmc_equilibrate(pmode, wait<span class="op">=</span><span class="dv">1</span>, mcmc_args<span class="op">=</span><span class="bu">dict</span>(niter<span class="op">=</span><span class="dv">1</span>, beta<span class="op">=</span>np.inf))</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a><span class="co"># get inferred modes</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>modes <span class="op">=</span> pmode.get_modes()</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, mode <span class="kw">in</span> <span class="bu">enumerate</span>(modes):</span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> mode.get_max_nested()    <span class="co"># mode's maximum</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>    pv <span class="op">=</span> mode.get_marginal(g)    <span class="co"># mode's marginal distribution</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Mode </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> with size </span><span class="sc">{</span>mode<span class="sc">.</span>get_M()<span class="op">/</span><span class="bu">len</span>(bs)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> state.copy(bs<span class="op">=</span>b)</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    state.draw(</span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>        vertex_shape<span class="op">=</span><span class="st">"pie"</span>,</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>        vertex_pie_fractions<span class="op">=</span>pv,</span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>        output_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">1200</span>),</span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>        output<span class="op">=</span><span class="ss">f"output/enron-partition-mode-</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>😎 We don’t have competing explanations in our posterior distribution! While there are minor differences in the partitions – as we’ve seen from our initial models in this notebook – there are no competing clusters with comparable high probability.</p>
<p>This code will list each mode in the posterior along with the <span class="kn-pink">collective posterior probability of the partitions in each mode</span>. The number of modes detected will depend on the posterior distribution for any given network, but of course the probabilities of all the modes combined will sum to 1. It will also create a series of plots, one for each mode in the posterior, that plots the marginal node block assignment probabilities by drawing the nodes as small pie charts, just like we did above. If there are multiple modes, this will help us compare the different stories or explanation that each partition tells.</p>
<p>Tomorrow, we’ll develop your generative modelling toolkit to include simulation and agent-based modelling!</p>
<ul>
<li><strong>TODO</strong>: This is the original text from the print edition. Update it / replace it with the new content I wrote for FCIT / GESIS. It’s much better.</li>
</ul>
</section>
<section id="bayesian-hierarchical-stochastic-blockmodels" class="level3" data-number="25.17.4">
<h3 data-number="25.17.4" class="anchored" data-anchor-id="bayesian-hierarchical-stochastic-blockmodels"><span class="header-section-number">25.17.4</span> Bayesian Hierarchical Stochastic Blockmodels</h3>
<p>Unlike their deterministic counterparts, Bayesian stochastic blockmodels conceptualize network structure as a latent variable problem to be addressed with a generative model. Just as LDA assumes that specific combination of words observed in documents are <em>generated</em> from shared latent themes, SBMs assume that specific patterns of ties between nodes in social networks are <em>generated</em> from some latent network structure that influences the formation and dissolution of relationships. The types of latent structure that we are interested in varies, and we can develop models for specific types of structure.</p>
<p>Having a probabilistic model of how this works, grounded in plausible generative mechanisms, is an important part of developing models that don’t under or overfit our data. It helps us differentiate structure from random noise in the process of moving from concrete connections between concrete nodes to general connections between categories of nodes. This allows us to overcome some of the limitations of deterministic approaches, which can be tripped up by structure that is caused by random fluctuations rather than some meaningful network-driven social process.</p>
<p>Tiago <span class="citation" data-cites="peixoto2019bayesian">T. P. Peixoto (<a href="references.html#ref-peixoto2019bayesian" role="doc-biblioref">2019</a>)</span> summarizes the Bayesian response to this problem in one pithy paragraph:</p>
<blockquote class="blockquote">
<p>“The remedy to this problem is to think probabilistically. We need to ascribe to each possible explanation of the data a probability that it is correct, which takes into account modeling assumptions, the statistical evidence available in the data, as well as any source of prior information we may have. Imbued in the whole procedure must be the principle of parsimony – or Occam’s razor – where a simpler model is preferred if the evidence is not sufficient to justify a more complicated one” (page 4).</p>
</blockquote>
<p>As with LDA, the underlying logic of developing a Bayesian generative model here is the same as in other contexts. To continue drilling that underlying logic:</p>
<ol type="1">
<li>we have observed data (connections between nodes in a network) and unobserved latent variables (block or community membership);</li>
<li>we want to infer the distributions of the latent variables (i.e., the assignment of nodes into latent blocks) conditional on the observed data;</li>
<li>to do so, we construct a joint probability distribution of every possible combination of values for our latent and observed variables (i.e., the numerator in Bayes theorem) and then perform approximate posterior inference to determine the probabilities of different distributions on the latent variables conditional on the observed data.</li>
</ol>
<p>We are after the posterior probabilities of many different partitions of the network conditioned on the connections we observe. In other words, we want to know the conditional probability that some node partition <span class="math inline">\(b\)</span> could have plausibly generated an observed network <span class="math inline">\(G\)</span>,</p>
<p><span class="math display">\[\begin{align}
P(\text{b}|\text{G})
\end{align}\]</span></p>
<p>As with all Bayesian models, we need to play the “what’s that” game, providing priors for all latent variables. The natural tendency here is to prefer uniform priors. If you recall from Chapter 28, using a uniform distribution for our priors means assigning an equal probability to every possible value of the latent variable. <span class="citation" data-cites="peixoto2019bayesian">T. P. Peixoto (<a href="references.html#ref-peixoto2019bayesian" role="doc-biblioref">2019</a>)</span> has shown, however, that this strategy often results in suboptimal results with network models, as it has an a priori preference for solutions with number of blocks comparable to the number of nodes in the network. Who wants that? Nobody. Instead, <span class="citation" data-cites="peixoto2019bayesian">T. P. Peixoto (<a href="references.html#ref-peixoto2019bayesian" role="doc-biblioref">2019</a>)</span> proposes a three-level hierarchical Bayesian approach where we sample (1) the number of blocks, (2) the sizes of each block, and the (3) the partition of the observed network into those blocks.</p>
<p>This hierarchical model is much less likely to overfit our data, and it does so without requiring us to determine the number of groups in advance, or indeed making any assumptions about the higher-order structure of the networks we are interested in. We will use this model exclusively below. It’s known as a <strong>nested Stochastic Blockmodel</strong>. <span class="citation" data-cites="peixoto2014hierarchical">T. Peixoto (<a href="references.html#ref-peixoto2014hierarchical" role="doc-biblioref">2014</a>)</span> describes a number of interesting variations on inference algorithms for this hierarchical model. One <em>very</em> important thing to know about the SBM implementation in graph-tool is that rather than strictly considering equivalence, it also considers the probability of nodes connecting to other nodes, in the more standard sense of network models we’ve looked at previously. This means that the network partitions from graph-tool will be based on a mixture of assortative community structure (as we’ve seen in Chapter 15 with Louvain and Leiden) along with disassortative (structural equivalence). Incorporating edge weights into the SBM estimation tends to push the balance in the results towards the assortative side, which makes some intuitive sense - a highly weighted connection between two nodes could drown out the latent influence of structural equivalence. We will examine this shortly.</p>
<p>This has all been very abstract. Let’s get our hands dirty with some code.</p>
</section>
</section>
<section id="blockmodelling-with-graph-tool" class="level2" data-number="25.18">
<h2 data-number="25.18" class="anchored" data-anchor-id="blockmodelling-with-graph-tool"><span class="header-section-number">25.18</span> BLOCKMODELLING WITH GRAPH-TOOL</h2>
<p>When it comes to the fitting Bayesian stochastic blockmodels, there’s no beating Tiago Peixoto’s graph-tool, in Python or otherwise. It has astonishing performance in terms of both speed and memory, and as a result it can handle exceptionally large networks efficiently. This performance is achieved by offloading most of the heavy lifting to C++ on the back-end. The cost of these performance improvements, however, is that using graph-tool is less “Pythonic” than you might be used to by this point in the book. Graph-tool is considerably more complex than the network analysis packages we’ve seen so far (Networkx and NDLib).</p>
<p>The additional overhead and less Pythonic nature that gives graph-tool it’s superior performance capabilities also means that I have to spend more time upfront describing how things work. It is entirely possible some of this won’t really “sink in” until you start working with graph-tool. That’s OK! Once you get your hands dirty with some models and have built up a bit of intuition, you can always come back to this content to deepen your understanding.</p>
<section id="installing-graph-tool" class="level3" data-number="25.18.1">
<h3 data-number="25.18.1" class="anchored" data-anchor-id="installing-graph-tool"><span class="header-section-number">25.18.1</span> Installing graph-tool</h3>
<p>The easiest way to get up and running with graph-tool is to install it via conda-forge with the following command. Because of its numerous dependencies, I strongly recommend that you do this inside a Conda environment (such as the dcss environment, if you’ve been following along with the supplementary learning materials). As a reminder, Conda environments were introduced in Chapter 2.</p>
<p><code>conda install -c conda-forge graph-tool</code></p>
<p>If you haven’t been using an environment already, you can also install graph-tool inside a conda environment designed specifically for graph-tool. You can use that environment the same way you use any other conda environment. To download and activate the graph-tool environment, simple execute the following from the command line:</p>
<p><code>conda create --name gt -c conda-forge graph-tool</code></p>
<p>When conda prompts you for permission to download and install the required packages, agree. When it’s finished, activate the environment with</p>
<p><code>conda activate gt</code></p>
<p>When you do so, you should see your command prompt change; it will now start with <code>(gt)</code> (as opposed to <code>dcss</code> if you’ve been using the conda environment for this book). If you are using Jupyter, note that you’ll have to launch your Jupyter Notebook server inside that environment to access the packages inside the environment.</p>
</section>
<section id="understanding-property-maps" class="level3" data-number="25.18.2">
<h3 data-number="25.18.2" class="anchored" data-anchor-id="understanding-property-maps"><span class="header-section-number">25.18.2</span> Understanding Property Maps</h3>
<p>The most important graph-tool concept to understand is how its array-like “property maps” work. Rather than attaching information about a node (e.g., its ID / label or degree centrality) to the node itself, each node in the network is assigned a unique index. That same index is contained in a property map, and whenever we want to know some information about a node, we use the node index to find the relevant information in the property map. There’s a bit of extra friction here, though: because of the C++ backend, each property map object contains <em>only one type of data</em>, that you have to declare in advance. This is a pain, but it’s what allows us to enjoy some pretty remarkable performance improvements.</p>
<p>Because graph-tool makes such heavy use of these array-like property maps, it’s easiest to think of a network in graph-tool as a collection of <em>associated arrays</em>. For example, in a network with three nodes – <code>['Lebron James', 'Anthony Davis', 'Kentavious Caldwell-Pope']</code> – and an associated property map of colours – <code>[Red, Green, Blue]</code> – <code>Lebron James</code> would be <code>Red</code>, <code>Antony Davis</code> would be <code>Green</code>, and <code>Kentavious Caldwell-Pope</code> would be <code>Blue</code>. We can encode just about anything in a property map, including vectors of values. For example, the <code>[Red, Green, Blue]</code> property map could also be stored as RGB values, <code>[[255,0,0], [0,128,0], [0,0,255]]</code>, which would associate <code>[255,0,0]</code> with <code>Lebron James</code>.</p>
<p>It’s also very important to note that</p>
<ol type="1">
<li>graph-tool does not automatically label nodes, and</li>
<li>it is possible for multiple nodes can have the same label.</li>
</ol>
<p>This can result in some unwelcome surprises. For example, if your edgelist contains strings <strong>as opposed to numbers</strong> – such as</p>
<pre><code>[
    ('Karamo', 'Tan'), 
    ('Karamo', 'Tan')
]</code></pre>
<p>then graph-tool will create four different nodes and two edges rather than creating two nodes and aggregating the edges into a weight of 2 for the tie between Karamo and Tan.</p>
<p>You might recall from Chapter 14 that different disciplines tend to use different words to refer to nodes and edges. In graph-tool, <strong>nodes are referred to as vertices</strong>. They are <em>exactly</em> the same. When we create a new vertex in graph-tool – <code>v = g.add_vertex()</code> – <code>v</code> becomes a <code>vertex</code> class object, which we can refer to as a <strong>vertex descriptor</strong>. Vertex descriptors are alternative to node indices and can be used to access information about a node from a property map. If we assigned our <code>[Red, Green, Blue]</code> property map to an object called <code>colour_map</code>, we could retrieve the information for node <code>v</code> with <code>colour_map[v]</code>.</p>
<p>Edge property maps, which can contain useful information such as edge weight, behave somewhat differently. They are accessed using <strong>edge descriptors</strong>, which can be obtained from the source and target nodes. For example, we might obtain and store an edge descriptor between nodes <code>Karamo</code> and <code>Tan</code> with <code>e = g.edge('Karamo','Tan')</code> or <code>e = g.edge(1, 2)</code> if you’ve assigned Karamo and Tan integer IDs to benefit from faster compute times.</p>
<p>Finally, entire networks can themselves can have property maps. These network-level property maps can be accessed by passing the graph object itself. For example, if we have a network object called <code>g</code> and a property map called <code>graph_property_map</code>, we could access the properties with <code>graph_property_map[g]</code>.</p>
<p>This might sound like a lot of additional overhead to worry about when conducting a network analysis, but you’ll likely find the impact fairly minimal once you get used to things. As with other network analysis packages, it makes it relatively easy to do a large amount of data processing outside of the package itself. For example, you can do a lot of work with the data that will eventually be stored as property maps using Pandas and Numpy. My main advice here is <em>take great care that all of the data in your lists and arrays are in the same order, and of equal lengths.</em></p>
<p>Now, let’s model.</p>
</section>
<section id="imports" class="level3" data-number="25.18.3">
<h3 data-number="25.18.3" class="anchored" data-anchor-id="imports"><span class="header-section-number">25.18.3</span> Imports</h3>
<div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> graph_tool.<span class="bu">all</span> <span class="im">import</span> <span class="op">*</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>pd.set_option(<span class="st">"display.notebook_repr_html"</span>, <span class="va">False</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pickle</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dcss.networks <span class="im">import</span> label_radial_blockmodel, get_block_membership</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="data" class="level3" data-number="25.18.4">
<h3 data-number="25.18.4" class="anchored" data-anchor-id="data"><span class="header-section-number">25.18.4</span> Data</h3>
<p>As usual, I suggest refreshing yourself on the data we are using here by returning to the overview of datasets from Chapter 1. In brief, the Enron email data is provided as two CSV files, one with the edges between employees who have exchanged emails with one another, and one with the organizational position of Enron employees.</p>
<p>When developing a blockmodel, we typically do so without having some external set of positions or roles that we want to approximate; the goal here is not supervised learning. However, for learning purposes, our goal will be to develop a blockmodel using relational data that mirrors job titles. The purpose of doing things this way is to illustrate the power of this approach to network analysis, as well as make the discussion of “positions” a bit less abstract. So, remember that when we talk about “positions” and “roles,” we don’t always (or even often) mean <em>official</em> positions or roles such as job titles.</p>
<p>The two datasets below contain the relational data from employee email communications and information about the job title each employees held in the organization.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>edges_df <span class="op">=</span> pd.read_csv(<span class="st">'data/enron/enron_full_edge_list.csv'</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>edges_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>                      source                             target
0    press.release@enron.com            all.worldwide@enron.com
1  office.chairman@enron.com             all.downtown@enron.com
2  office.chairman@enron.com      all.enron-worldwide@enron.com
3    press.release@enron.com            all.worldwide@enron.com
4  office.chairman@enron.com  all_enron_north.america@enron.com</code></pre>
<p>As you can see, our edgelist has two columns, <code>source</code> and <code>target</code>. We don’t have any edge weights (though we will compute them below) or other edge attributes.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>employee_df <span class="op">=</span> pd.read_csv(<span class="st">'data/enron/enron_employees_updated.csv'</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>employee_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>                           id                  position
0        liz.taylor@enron.com  Administrative Assistant
1    michelle.lokay@enron.com  Administrative Assistant
2  holden.salisbury@enron.com                   Analyst
3        kam.keiser@enron.com                   Analyst
4   matthew.lenhart@enron.com                   Analyst</code></pre>
<p>The information about each employee’s <em>official</em> position in the organization is provided in a column called <code>'position'</code>. Let’s count the number of employees in each role.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>employee_df[<span class="st">'position'</span>].value_counts()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>Trader                      35
Vice President              26
Director                    17
Manager                     15
In House Lawyer             11
Senior Specialist            8
Specialist                   6
Managing Director            6
Analyst                      5
Employee                     5
President                    4
CEO                          4
Administrative Assistant     2
Associate                    2
Senior Manager               1
COO                          1
CFO                          1
Name: position, dtype: int64</code></pre>
<section id="constructing-the-communication-network" class="level4" data-number="25.18.4.1">
<h4 data-number="25.18.4.1" class="anchored" data-anchor-id="constructing-the-communication-network"><span class="header-section-number">25.18.4.1</span> Constructing the Communication Network</h4>
<p>To create our network, let’s construct a weighted communication network between core employees using the edgelist and node attribute files above. First, we’ll aggregate and count edges to compute a weight. We’ll ignore any nodes that are not in the <code>employee_df</code> dataframe, narrowing our focus to core employees only. The “core employees” are those who were involved the legal proceedings following the Enron scandal.</p>
<p>Since this is a <strong>directed communication network</strong>, <code>i,j</code> ties are different than <code>j,i</code> ties, so we can simply aggregate our edges dataframe by the combination of <code>'source'</code> and <code>'target'</code> columns and treat the count of their occurrences as our edge weight. We’ll also filter the resulting dataframe so that it only includes nodes that are part of the core employee subset.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>edges_df <span class="op">=</span> edges_df.value_counts([<span class="st">'source'</span>, <span class="st">'target'</span>]).reset_index(name<span class="op">=</span><span class="st">'count'</span>).copy()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>core_employees <span class="op">=</span> <span class="bu">set</span>(employee_df[<span class="st">'id'</span>].tolist())</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>core_edges_df <span class="op">=</span> edges_df[edges_df[<span class="st">'source'</span>].isin(core_employees) <span class="op">&amp;</span> </span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>                         edges_df[<span class="st">'target'</span>].isin(core_employees)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With our weighted directed edgelist created, we can initialize a directed network.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>eG <span class="op">=</span> Graph(directed <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can add the core employees to this network as nodes, add their job titles to a property map, and add the edge data (weights) to a property map. We’ll do that in three steps:</p>
<ol type="1">
<li>get the information into lists,</li>
<li>initialize the property maps and tell graph-tool what type of data they we are going to provide, and</li>
<li>loop over our two lists to add the employees to the networks and their node and edge attributes (job titles, edge weights) to property maps.</li>
</ol>
<p>First, create the lists!</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>employee_list <span class="op">=</span> employee_df[<span class="st">'id'</span>].tolist()</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>title_list <span class="op">=</span> employee_df[<span class="st">'position'</span>].tolist()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Second, initialize the property maps! Note that in addition to the property maps themselves, we are creating a dictionary called <code>vertex_lookup</code>. As mentioned earlier in the chapter, we can use this to dictionary to simplify the ‘lookup’ process to select nodes using string values that carry some meaning about the node, rather than the integer identifier used by graph-tool.</p>
<p>Since we are going to use email addresses as node labels, we’ll initialize a property map called <code>labels</code> and tell graph-tool to expect strings (because email addresses are strings). Similarly we will initialize a property map for job titles, called <code>titles</code>, and also containing strings. Finally, we will create an <code>edge_weight</code> property map. Since edge weights are integers in this case, we will tell graph-tool to expect integers.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>vertex_lookup <span class="op">=</span> {}</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>label <span class="op">=</span> eG.new_vertex_property(<span class="st">'string'</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>title <span class="op">=</span> eG.new_vertex_property(<span class="st">'string'</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>edge_weight <span class="op">=</span> eG.new_edge_property(<span class="st">'int'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we’re ready to add information to the property maps! Let’s zip up our <code>employee_list</code> and <code>title_list</code> and then iterate over it. For each pairing of elements from the two lists, we’ll add the core employees to the network as nodes, their email addresses to the <code>labels</code> property map, and their job titles to the <code>titles</code> property map. Finally, we will add the information about the node index to the <code>vertex_lookup</code> dict we created above.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> vertex <span class="kw">in</span> <span class="bu">zip</span>(employee_list, title_list):</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create a new vertex instance</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> eG.add_vertex()</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add attributes to the property maps in the index position of the vertex</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    label[v] <span class="op">=</span> vertex[<span class="dv">0</span>]</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    title[v] <span class="op">=</span> vertex[<span class="dv">1</span>]</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add the vertex to the lookup dictionary, converting it to an integer </span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    vertex_lookup[vertex[<span class="dv">0</span>]] <span class="op">=</span> <span class="bu">int</span>(v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As you probably anticipated, the next thing we need to do is process the edges between nodes. We can do that by using lists pulled from the edges dataframe, but remember we <em>also</em> need to consult <code>vertex_lookup</code> to ensure we are assigning the right edges between the right nodes!</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>source_list <span class="op">=</span> core_edges_df[<span class="st">'source'</span>].tolist()</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>target_list <span class="op">=</span> core_edges_df[<span class="st">'target'</span>].tolist()</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>weight_list <span class="op">=</span> core_edges_df[<span class="st">'count'</span>].tolist()</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> nodes <span class="kw">in</span> <span class="bu">zip</span>(source_list, target_list, weight_list):</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    from_idx <span class="op">=</span> vertex_lookup[nodes[<span class="dv">0</span>]]</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    to_idx <span class="op">=</span> vertex_lookup[nodes[<span class="dv">1</span>]]</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Let's ignore self-loops</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> from_idx <span class="op">!=</span> to_idx:</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>        edge <span class="op">=</span> eG.add_edge(from_idx, to_idx)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>        edge_weight[edge] <span class="op">=</span> nodes[<span class="dv">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ve now reached the very final bit of preparation. We’ll make each of the property maps we’ve just initialized and populated with information <em>internal to the graph</em> and save the graph in <code>graph-tool</code>’s own format. That way we don’t need to recreate the network again later, we can just load up the network with all the relevant property maps already defined.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>eG.vertex_properties[<span class="st">'label'</span>] <span class="op">=</span> label</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>eG.vertex_properties[<span class="st">'title'</span>] <span class="op">=</span> title</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>eG.edge_properties[<span class="st">'edge_weight'</span>] <span class="op">=</span> edge_weight</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>lookup <span class="op">=</span> eG.new_graph_property(<span class="st">'object'</span>)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>lookup[eG] <span class="op">=</span> vertex_lookup</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>eG.graph_properties[<span class="st">'vertex_lookup'</span>] <span class="op">=</span> lookup</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And with that, we’re ready to start developing stochastic blockmodels!</p>
</section>
</section>
<section id="developing-stochastic-blockmodels" class="level3" data-number="25.18.5">
<h3 data-number="25.18.5" class="anchored" data-anchor-id="developing-stochastic-blockmodels"><span class="header-section-number">25.18.5</span> Developing Stochastic Blockmodels</h3>
<p>In the introduction, we discussed how there are some properties that stochastic blockmodels share with LDA. One of those properties is the process for developing, critiquing, improving, and eventually selecting the best model in an iterative fashion: Box’s loop. For example, in this case, after approximating the posterior distribution of the latent variables, we can test the fit of that posterior on the data, and repeat the process using the insight gained about what is and isn’t working in the model. In theory, enough iterations would produce the best model possible in terms of representing the data (<em>not</em> in terms of the usefulness of the results). In practice, we have to make a choice about when we’re satisfied with the results, because there’s no good way to know how many iterations it would take to produce the best model you can given the data you have.</p>
<p>As I mentioned earlier, our goal here is to develop a blockmodel that will partition our network into a set of positions that mirror the job titles that the core employees held within Enron. The catch, of course, is that we want to do this using only information from the relational data itself.</p>
<p>graph-tool has a very handy function, <code>minimize_nested_blockmodel_dl()</code>, that takes care of all the hard work for us. It’s fast to run, and tends to produce good results right out of the box. <code>minimize_nested_blockmodel_dl()</code> attempts to minimize something called the “<strong>description length</strong>” of a nested blockmodel. Let’s break this down, starting with the nested part. As you hopefully recall from earlier in this chapter, a <em>nested</em> stochastic blockmodel is a hierarchical Bayesian model. In other words, it embeds blocks inside other blocks in a <strong>multi-level hierarchy</strong>. Doing things this way makes it easier to find small blocks in a network that may contain a small number of nodes.</p>
<p>The <code>minimize</code> and <code>dl</code> parts of <code>minimize_nested_blockmodel_dl()</code> are a shorthand for <strong>minimize the description length</strong>. Minimum description length is an operationalization of Occam’s razor; it suggests that the best model is one that can represent all of the data with the least amount of information required. It helps us select a model that fully explains the data but is as simple as possible given the observed data.</p>
<p>Finally, the blockmodel we will fit here is also <strong>degree-corrected</strong> <span class="citation" data-cites="karrer2011stochastic">(<a href="references.html#ref-karrer2011stochastic" role="doc-biblioref">Karrer and Newman 2011</a>)</span>. A standard baseline SBM assumes that nodes within any given block tend to have very similar, if not identical, degrees. Since this is <em>extremely unrealistic</em> in real world networks, it is almost always better to use the degree-corrected implementation.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> minimize_nested_blockmodel_dl(eG, deg_corr <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With that one line of code, we’ve executed our 3-level Hierarchical Bayesian Stochastic Blockmodel!</p>
<p>The function we just executed created something called a <strong>blockstate</strong>, which is an object containing the results of partitioning the network running our blockmodel. We can print a summary of the blockstate for our nested degree-corrected description-length-minimized blockmodel to find out</p>
<ul>
<li>the number of blocks that nodes were assigned to,</li>
<li>the number of levels in the nested hierarchy, and</li>
<li>the number of “<strong>meta-blocks</strong>” at each of those levels (blocks within blocks in the nested hierarchy).</li>
</ul>
<div class="sourceCode" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>state.print_summary()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>l: 0, N: 149, B: 13
l: 1, N: 13, B: 4
l: 2, N: 4, B: 1</code></pre>
<p>Remember that the model we just ran is a <em>stochastic generative model</em>, so the number of blocks will vary for each run of the model, but it typically finds 12-14 blocks at the bottom level. Remember, this is a nested variant where the “bottom level” consists of all the individual nodes, while the upper levels of the hierarchy are aggregate blocks, found by creating a new network where each block is a node and estimating a blockmodel based on that network. After some consideration, 12-14 blocks seems fairly reasonable. We have 17 job titles in the data but if we combined “Manager + Senior Manager”, “Senior Specialist + Specialist”, “Administrative Assistant + Employee”, and “CEO + CFO + COO”, we’d have 12 titles. This kind of combination would not impact the computation of the model at all and can be left until it’s time for interpretation.</p>
<p>Finally, we can get a quick sense of how things went by visualizing the blockmodel (<span class="quarto-unresolved-ref">?fig-31_01</span>). I’m limited to a narrow colour palette in print, but you can access a full resolution colour version of the image (and others like it) in the supplementary online materials. I recommend looking at the color versions of these images, as colour is used very effectively in these blockmodel visualizations.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>state.draw(</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    layout <span class="op">=</span> <span class="st">"sfdp"</span>, </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    vertex_text <span class="op">=</span> eG.vertex_properties[<span class="st">'title'</span>], </span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    eorder <span class="op">=</span> eG.edge_properties[<span class="st">'edge_weight'</span>],</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    vertex_text_position <span class="op">=</span> <span class="dv">315</span>,</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">1</span>],</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>[<span class="dv">4024</span>,<span class="dv">4024</span>],</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    output<span class="op">=</span><span class="st">'figures/core_enron_blockmodel_sfdp.pdf'</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="figures/core_enron_blockmodel_sfdp1.pdf" class="img-fluid"></p>
<figcaption>Cap</figcaption>
</figure>
</div>
<p>In this figure, each node is represented by an individual point (as in other network visualiztions), only the nodes are organized into blocks. The squares are points where blocks converge up the hierarchy to form the nested structure - the structure of email exchanges between blocks will decide whether a block should be grouped with another one. For example, if you look at the group of 6 blocks in the top left of the image, you might notice that there are only two traders present, but there are a lot of lawyers and vice presidents, as well as a CEO.</p>
<p>This first attempt is already looking pretty good. We have 3 of the 4 CEOs in the same block near the right-hand side, along with three presidents. Note for later: the remaining CEO isn’t in the same meta-block - one level up the hierarchy - as the other CEOs.</p>
<p>As with other generative models, <em>we need to think through generative mechanisms here</em>. If you recall from Chapter 25, all this really means is that we need to think through simple social and interactional processes that may have resulted in (i.e., generated) the patterns we see in our data. <em>What’s a plausible story of how this data was generated?</em></p>
<p>Remember that we are detail with <em>email communication</em> between employees in an organization here. There are many ways to imagine the social mechanisms that best predict structure in a network like this. In this case, it could be that emails between the core employees predicts the relationship between those employees, or it could be that the emails they send <em>to other non-core employee Enron email addresses</em> are more predictive. This is an exploratory process that can’t fit reasonably in this chapter, but you can see a bit of it in the online supplement.</p>
<p>Let’s see what the outcome is with different blockmodel estimation criteria. Stochastic blockmodels in graph-tool are able to incorporate edge weights into the estimation.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>state_w <span class="op">=</span> minimize_nested_blockmodel_dl(eG, deg_corr <span class="op">=</span> <span class="va">True</span>, </span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>                                              state_args<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>                                                  recs<span class="op">=</span>[eG.edge_properties[<span class="st">'edge_weight'</span>]],</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>                                                  rec_types<span class="op">=</span>[<span class="st">"discrete-binomial"</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>state_w.print_summary()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>l: 0, N: 149, B: 67
l: 1, N: 67, B: 10
l: 2, N: 10, B: 2
l: 3, N: 2, B: 1</code></pre>
<p>We can see already that we end up with far too many blocks to be useful here! There’s no need to visualize this graph, but we have another option - let’s try setting the number of blocks to be the same as it was for the unweighted model, then see what the weights do for the results.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>state_w2 <span class="op">=</span> minimize_nested_blockmodel_dl(eG, deg_corr <span class="op">=</span> <span class="va">True</span>, B_min<span class="op">=</span><span class="dv">12</span>, B_max<span class="op">=</span><span class="dv">12</span>,</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>                                              state_args<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>                                                  recs<span class="op">=</span>[eG.edge_properties[<span class="st">'edge_weight'</span>]],</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>                                                  rec_types<span class="op">=</span>[<span class="st">"discrete-binomial"</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>state_w2.print_summary()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>l: 0, N: 149, B: 12
l: 1, N: 12, B: 3
l: 2, N: 3, B: 2
l: 3, N: 2, B: 1</code></pre>
<p>At first glance (<span class="quarto-unresolved-ref">?fig-31_02</span>), incorporating edge weight seems as though it produces more tightly-knit, smaller blocks, and only two distinct groups of blocks one level up the hierarchy where we had four with the first model. The larger blocks are also more heterogenous, with CEO’s grouped alongside many traders and even “employees”.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>state_w2.draw(</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    layout <span class="op">=</span> <span class="st">"sfdp"</span>, </span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    vertex_text <span class="op">=</span> eG.vertex_properties[<span class="st">'title'</span>], </span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    eorder <span class="op">=</span> eG.edge_properties[<span class="st">'edge_weight'</span>],</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    vertex_text_position <span class="op">=</span> <span class="dv">315</span>,</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">1</span>],</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>[<span class="dv">4024</span>,<span class="dv">4024</span>],</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    output<span class="op">=</span><span class="st">'figures/core_enron_blockmodel_sfdpw.pdf'</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="figures/core_enron_blockmodel_sfdpw1.pdf" class="img-fluid"></p>
<figcaption>Cap</figcaption>
</figure>
</div>
<p>The use of edge weights in a blockmodel is a theoretical consideration more than it is a technical one, so it takes some careful thought and experimenting to see what the impact is. In our case, we have people with quite different roles in the company, so their email volume will be quite different. If we don’t use edge weights, we stick to a stricter definition of equivalence, closer to structural, and here this produces the most intuitive results. Nonetheless, we should have a way to compare the results beyond just looking at a graph - these graphs won’t be very helpful for huge networks. We can use the <code>get_block_membership</code> utility from the dcss package to add block assignment information to the employee dataframe.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>employee_blocks_df <span class="op">=</span> get_block_membership(state, eG, employee_df,</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>                                         <span class="st">'model_uw_1'</span>)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>employee_blocks_df <span class="op">=</span> get_block_membership(state_w2, eG, employee_blocks_df,</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>                                         <span class="st">'model_w_2'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s take a look at some of the job titles that one would expect to be more well-defined.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>df_by_position <span class="op">=</span> employee_blocks_df.groupby(<span class="st">'position'</span>).agg(<span class="bu">list</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>df_by_position[df_by_position.index.isin([<span class="st">'CEO'</span>,<span class="st">'President'</span>, <span class="st">'In House Lawyer'</span>])].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>                                                                id  \
position                                                             
CEO              [david.w.delainey@enron.com, jeff.skilling@enr...   
In House Lawyer  [bill.rapp@enron.com, carol.clair@enron.com, d...   
President        [greg.whalley@enron.com, jeffrey.a.shankman@en...   

                                 model_uw_1_block_id  \
position                                               
CEO                                     [5, 5, 0, 0]   
In House Lawyer  [1, 9, 10, 10, 9, 7, 5, 3, 9, 9, 3]   
President                              [5, 5, 0, 12]   

                                model_w_2_block_id  
position                                            
CEO                                   [0, 5, 1, 5]  
In House Lawyer  [9, 9, 0, 8, 2, 8, 3, 5, 6, 1, 6]  
President                             [2, 2, 1, 5]  </code></pre>
<p>You might be able to get a sense of things from some of the smaller lists here. For example, in the <code>model_uw_1_block_id</code> column, we can see that one block has 3 of the 4 CEOs, as well as 3 of the 4 Presidents, while another has the remaining CEO and President. 6 of the lawyers also tend to end up in the same block on this run (again, this is stochastic so results might vary a little bit). With the weighted model, only two of the CEOs end up in the same block, although they are joined by a President and a lawyer.</p>
<p>Alternatively, we can count the number of unique block assignments by role (job title) and calculate the average, based on the number of people with those roles. A lower value here would be a loose indicator of accuracy, with two caveats: a 0.5 value for CEO would be the same if the 4 CEOs were divided equally into two blocks, rather than 3 in one block and 1 in another. This block assignment difference is conceptually significant, so a more robust metric might be desirable. Job titles that apply to only 1 employee will also, necessarily, have a perfectly poor score of 1.0 every time.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>employee_blocks_df.groupby([<span class="st">'position'</span>])[<span class="st">'model_uw_1_block_id'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>position
Administrative Assistant    1.000000
Analyst                     0.400000
Associate                   1.000000
CEO                         0.500000
CFO                         1.000000
COO                         1.000000
Director                    0.411765
Employee                    0.600000
In House Lawyer             0.545455
Manager                     0.466667
Managing Director           0.666667
President                   0.750000
Senior Manager              1.000000
Senior Specialist           0.875000
Specialist                  0.500000
Trader                      0.200000
Vice President              0.423077
Name: model_uw_1_block_id, dtype: float64</code></pre>
<div class="sourceCode" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(employee_blocks_df.groupby([<span class="st">'position'</span>])[<span class="st">'model_uw_1_block_id'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count()).<span class="bu">sum</span>())</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(employee_blocks_df.groupby([<span class="st">'position'</span>])[<span class="st">'model_w_2_block_id'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count()).<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>11.338629507747154
11.916386064915477</code></pre>
<p>We can do the exact inverse to roughly assess the homogeneity of the blocks, by reversing the columns in the groupby operation.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>employee_blocks_df.groupby([<span class="st">'model_uw_1_block_id'</span>])[<span class="st">'position'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>model_uw_1_block_id
0     0.750000
1     0.583333
2     0.277778
3     0.476190
4     0.555556
5     0.416667
6     0.230769
7     0.625000
8     0.714286
9     0.400000
10    0.666667
11    0.500000
12    0.666667
Name: position, dtype: float64</code></pre>
<div class="sourceCode" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(employee_blocks_df.groupby([<span class="st">'model_uw_1_block_id'</span>])[<span class="st">'position'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count()).<span class="bu">sum</span>())</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(employee_blocks_df.groupby([<span class="st">'model_w_2_block_id'</span>])[<span class="st">'position'</span>].agg(<span class="kw">lambda</span> x: x.nunique()<span class="op">/</span>x.count()).<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6.862912087912089
7.970732305329079</code></pre>
<p>This loose evaluation suggests that the unweighted model might be preferred, but we can do better with this evaluation. Sci-kit learn provides <em>many</em> classification evaluation metrics and the problem we’re solving here is essentially a clustering classification. There are metrics within sklearn’s clustering section that provide the above evaluations but with more nuance (remember the equivalent 0.5 score if the CEOs were clustered with different proportions but the same number of blocks). A <code>homogeneity_score</code> evaluates, you guessed it, the homogeneity of the detected clusters, so if clusters contain more of the same type of job title, the results will score higher. Scores here are on a scale from 0 to 1, with 1 being the best.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> homogeneity_score, completeness_score, adjusted_mutual_info_score</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s compare homogeneity scores for the unweighted network and then the weighted one. As with the rough evaluation above, the unweighted model has a better score.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>homogeneity_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_1_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.353428152904928</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>homogeneity_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_w_2_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.25528558562493037</code></pre>
<p>The <code>completeness_score</code> inverts the previous score, instead assessing the homogeneity of block assignments for each job titles, so the degree to which nodes are assigned to blocks with other nodes that have the same title. The result is actually very similar in this case!</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>completeness_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_1_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.3435558493343224</code></pre>
<div class="sourceCode" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>completeness_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_w_2_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.2771316517440044</code></pre>
<p>Finally, we can also do both of the above in a unified score, <code>adjusted_mutual_info_score</code>, where homogeneity and completeness are considered together and the position of the ground-truth and predicted labels doesn’t matter. This can also be used to calculate agreement between two labelling methods, when there is no known ground-truth, but unfortunately our block assignment classifications will not be the same between models - <code>block 1</code> in one model is not necessarily the same as <code>block 1</code> in the next, or even in repeat runs of the same model. Note that this method is a version of <code>normalized_mutual_info_score</code> that is adjusted to account for chance, because the standard mutual information score tends to overestimate the shared information between models that have a larger number of clusters.</p>
<p>For this score, the maximum is 1 but it is possible to have a negative score if the predicted clusters are nonsensical enough. We can see that the adjusted mutual info score below is roughly half of the individual scores above, for the unweighted network. For the weighted network, the score is <em>much</em> lower. If we compare the two block assignments together, they actually have more agreement with each other than the weighted model has with the ground truth job titles.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>adjusted_mutual_info_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_1_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.15309516996415473</code></pre>
<div class="sourceCode" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>adjusted_mutual_info_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_w_2_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.0756412457785869</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>adjusted_mutual_info_score(employee_blocks_df[<span class="st">'model_w_2_block_id'</span>], employee_blocks_df[<span class="st">'model_uw_1_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.15563023649762936</code></pre>
<p>With this information in mind, let’s continue on with the unweighted network to see if we can optimize it more, then examine the end result.</p>
</section>
<section id="model-selection-and-optimization" class="level3" data-number="25.18.6">
<h3 data-number="25.18.6" class="anchored" data-anchor-id="model-selection-and-optimization"><span class="header-section-number">25.18.6</span> Model Selection and Optimization</h3>
<p>Given the stochastic nature of these models, it is always advisable to run them a number of times and then select the model with the least entropy. Higher entropy is not <em>inherently</em> bad. <strong>Properly discuss entropy here, and why we care</strong>. For example, a compressed JPEG image with only two colours will have a lot less entropy than one with a thousand colours.</p>
<p>In the case of stochastic block models, entropy returns the minimum description length, which is the amount of information the model needs to recreate the entire network. The goal of reducing entropy is fundamental to these models, with the assumption that minimizing entropy results in simpler models that do a better job of uncovering latent similarities in the data without overfitting. Below, we’ll execute 10 runs of <code>minimize_nested_blockmodel_dl</code> and print the entropy for each.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> [minimize_nested_blockmodel_dl(eG, deg_corr<span class="op">=</span><span class="va">True</span>) </span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>)]</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s <span class="kw">in</span> states:</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(s.entropy())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6162.281933127059
6187.135324492942
6168.918484063684
6161.190122173799
6163.517013260514
6162.876759036053
6178.052196472743
6154.1481501809185
6166.798460034726
6154.869718381805</code></pre>
<p>We can automatically grab the lowest entropy state using <code>np.argmin</code>.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> states[np.argmin([s.entropy() <span class="cf">for</span> s <span class="kw">in</span> states])]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="more-mcmc" class="level3" data-number="25.18.7">
<h3 data-number="25.18.7" class="anchored" data-anchor-id="more-mcmc"><span class="header-section-number">25.18.7</span> More MCMC</h3>
<p>At the expense of increased runtime, we can also follow-up the above model selection process by sampling from the posterior distribution and running <code>mcmc_equilibrate</code>, which performs random changes in the block assignments of the nodes, automatically handles the entropy calculations, and chooses the optimum values at the end. This step is also required to collect the block assignment posterior marginals, which tell us the likelihood (if any) that a node belongs to each block, based on the assignments it was given during the iterations. More iterations here will always improve the model, but with decreasing improvement/run-time payoffs.</p>
<p>First, we will use the object <code>S1</code>, defined below, to keep track of the original entropy score to see how much we improved the model.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>S1 <span class="op">=</span> state.entropy()</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>S1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6154.1481501809185</code></pre>
<p>To collect marginal probabilities with MCMC, the blockstate needs to have been prepared for sampling, rather than for minimizing description length, which we can achieve by copying the blockstate and setting sampling to <code>True</code>. At the same time, we will add an additional 4 empty levels to the nested hierarchy so that the model has a chance to assign more levels. If these hierarchy levels don’t improve the model, the equilibration method will collapse them.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> state.copy(bs<span class="op">=</span>state.get_bs() <span class="op">+</span> [np.zeros(<span class="dv">1</span>)] <span class="op">*</span> <span class="dv">4</span>,sampling <span class="op">=</span> <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’re going to perform many iterations of the <code>mcmc_equilibrate</code> function, where nodes are moved between different blocks. Importantly, the MCMC method used in graph-tool doesn’t perform fully random moves, which would be a fairly typical MCMC approach. By taking advantage of the assumption that networks are made up of heavily interdependant observations, the MCMC estimation only has to randomly sample from probable block assignment moves - to the blocks that a node’s alters are members of.</p>
<p>We create a callback function to pass to <code>mcmc_equilibrate</code> so that we can collect a set of block assignment choices from each iteration. The <code>bs</code> values can be thought of as votes for block re-assignment, and constitute the posterior marginal probability of each node’s assignment to each block.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>bs <span class="op">=</span> []</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co">## OUR CALLBACK FUNCTION THAT APPENDS EACH ESTIMATED BLOCKSTATE TO THE ARRAY</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> collect_partitions(s):</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> bs</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    bs.append(s.get_bs())</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>mcmc_equilibrate(state, force_niter<span class="op">=</span><span class="dv">10000</span>, mcmc_args<span class="op">=</span><span class="bu">dict</span>(niter<span class="op">=</span><span class="dv">10</span>), callback<span class="op">=</span>collect_partitions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>(6159.927069603201, 37378153, 4808499)</code></pre>
<p>Note that this will sometimes result in higher entropy for the block model solution! That’s because we need to select the best partition from the ones added to the <code>bs</code> list by the callback function.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>state.entropy() <span class="op">-</span> S1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>5.778919422760737</code></pre>
<p>The <code>PartitionModeState</code> function takes our set of labeled partitions and tries to align them into a single set of common group labels. We can then use the <code>get_marginal()</code> method of the returned object to create a vertex property map of marginal probabilities for our original network graph. This property map can be used for calculations as well as for visualization of probable block memberships.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>pmode <span class="op">=</span> PartitionModeState(bs, nested<span class="op">=</span><span class="va">True</span>, converge<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>pv <span class="op">=</span> pmode.get_marginal(eG)</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>eG.vertex_properties[<span class="st">'pv'</span>] <span class="op">=</span> pv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, the convenience function <code>get_max_nested()</code> returns the most likely block assignment for each node as a single final blockstate, which will group nodes in proximity to each other in our visualization, based on their most likely membership. We apply this result back to our original blockstate object by providing it to the <code>copy()</code> method of the state object. Note that our entropy has improved a bit more here!</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>bs <span class="op">=</span> pmode.get_max_nested()</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> state.copy(bs<span class="op">=</span>bs)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>state.entropy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>6153.278269237107</code></pre>
<p>Let’s re-calculate the same mutual information scores we used earlier to see if things have improved on those criteria.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>employee_blocks_df <span class="op">=</span> get_block_membership(state, eG, employee_blocks_df, <span class="st">'model_uw_mcmc'</span>)</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>homogeneity_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_mcmc_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.38131989351325507</code></pre>
<div class="sourceCode" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>completeness_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_mcmc_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.3526819549124348</code></pre>
<p>Homogeneity improves from 0.35 to almost 0.39, while completeness only improves a small amount.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>adjusted_mutual_info_score(employee_blocks_df[<span class="st">'position'</span>], employee_blocks_df[<span class="st">'model_uw_mcmc_block_id'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>0.1561547346951431</code></pre>
<p>But the adjusted mutual info score below is actually slightly worse than it was before! This doesn’t necessarily mean the results are worse, though. We’ll take a look at a different layout for the blockmodel below and discuss some potential explanations for this.</p>
</section>
<section id="visualizing-block-connections-as-a-radial-tree" class="level3" data-number="25.18.8">
<h3 data-number="25.18.8" class="anchored" data-anchor-id="visualizing-block-connections-as-a-radial-tree"><span class="header-section-number">25.18.8</span> Visualizing Block Connections as a Radial Tree</h3>
<p>While the sfdp layout does a nice job of positioning nodes (and blocks) in spatial relation to each other, the radial tree layout can be very helpful for getting a sense of the connection patterns between the blocks and also keeps nodes together in a way that makes individual blocks very easy to distinguish. Since it is the default layout for printing a block state, we can easily obtain a simple representation using the <code>.draw()</code> method (see <span class="quarto-unresolved-ref">?fig-31_03</span>).</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>state.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="chapter_31_latent_network_structure_stochastic_block_models_files/chapter_31_latent_network_structure_stochastic_block_models_94_0.pdf" class="img-fluid"></p>
<figcaption>png</figcaption>
</figure>
</div>
<pre><code>(&lt;VertexPropertyMap object with value type 'vector&lt;double&gt;', for Graph 0x7f74c8ac3670, at 0x7f74c43f4a00&gt;,
 &lt;Graph object, directed, with 172 vertices and 171 edges, at 0x7f74c433b9d0&gt;,
 &lt;VertexPropertyMap object with value type 'vector&lt;double&gt;', for Graph 0x7f74c433b9d0, at 0x7f74c431ea90&gt;)</code></pre>
<p>As is often the case, there are a few preparation steps we can do to improve the visualization of edges, as well as to add node labels to our figure. This process is a bit complex and is an adaptation of one that was devised by the author of graph-tool. The details aren’t particularly important, so we can use the utility function <code>label_radial_blockmodel</code> from the dcss package to take care of most of it.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>eG <span class="op">=</span> label_radial_blockmodel(eG, state)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The resulting figure is much improved (<span class="quarto-unresolved-ref">?fig-31_04</span>), and clearly shows the relations between blocks, while also making it easier to examine which job titles were assigned to each block.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>state.draw(</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    vertex_text <span class="op">=</span> eG.vertex_properties[<span class="st">'title'</span>], </span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    eorder <span class="op">=</span> eG.edge_properties[<span class="st">'edge_weight'</span>],</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>    vertex_shape<span class="op">=</span><span class="st">'pie'</span>,</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>    vertex_pie_fractions<span class="op">=</span>eG.vertex_properties[<span class="st">'pv'</span>],</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>    edge_control_points <span class="op">=</span> eG.edge_properties[<span class="st">'cts'</span>],</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>    pos<span class="op">=</span>eG.vertex_properties[<span class="st">'pos'</span>], </span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>    vertex_size<span class="op">=</span><span class="dv">10</span>, </span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>    edge_pen_width <span class="op">=</span> <span class="fl">0.2</span>,</span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>    bg_color<span class="op">=</span>[<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">255</span>,<span class="dv">1</span>],</span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>    vertex_text_rotation<span class="op">=</span>eG.vertex_properties[<span class="st">'text_rot'</span>],</span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>    vertex_text_position<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>    output<span class="op">=</span><span class="st">'figures/core_state_radial_tree_labels.pdf'</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>(&lt;VertexPropertyMap object with value type 'vector&lt;double&gt;', for Graph 0x7f74c8ac3670, at 0x7f7550a574f0&gt;,
 &lt;Graph object, directed, with 172 vertices and 171 edges, at 0x7f7550a4d700&gt;,
 &lt;VertexPropertyMap object with value type 'vector&lt;double&gt;', for Graph 0x7f7550a4d700, at 0x7f7550a55970&gt;)</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="figures/core_state_radial_tree_labels1.pdf" class="img-fluid"></p>
<figcaption>Cap</figcaption>
</figure>
</div>
<p>You’ll notice that some of the nodes are broken up into pie fractions - these indicate their probability of being assigned to a different block. In the full colour version, these fractions are coloured the same as the alternative block that the node might have been assigned to. You’ll also notice that the blocks have become significantly more heterogenous! Traders are in blocks with other traders, most lawyers are in a block that two other lawyers had some probability of being assigned to, and the CEOs are in fairly exclusive blocks. Although we no longer have 3 CEOs in one block with the COO, the block that one of the CEOs was moved to contains the other CEO, and their two respective blocks form a single block one level up the hierarchy! Earlier I mentioned that there are possible explanations for a decreased adjusted mutual information score and this is one example - that score doesn’t incorporate the higher levels of the hierarchy. Even though it’s probably actually a better model to have the four CEOs split evenly among two blocks, then put those two blocks together at the next hierarchy level, this would still negatively impact the mutual info score compared to the model where 3 CEOs were in one block.</p>
<p>It’s quite clear from the results of these stochastic blockmodels that there’s some very powerful estimation going on, and that the Bayesian aspects of it allow a great deal of nuance. The versatility of the modeling that drives graph-tool has led to a collaborative extension for topic modeling. Given the relational nature of words in text, which is often analyzed in the same way as social relations, topics can be blockmodelled from text documents to great effect. We’ll explore this method in the section that follows.</p>
</section>
</section>
<section id="conclusion" class="level2" data-number="25.19">
<h2 data-number="25.19" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">25.19</span> CONCLUSION</h2>
<section id="key-points" class="level3" data-number="25.19.1">
<h3 data-number="25.19.1" class="anchored" data-anchor-id="key-points"><span class="header-section-number">25.19.1</span> Key Points</h3>
<ul>
<li>Hierarchical Stochastic Blockmodels are remarkably powerful models that provide a nearly unparalleled degree of insight into the structure of a network and nodes’ roles within it</li>
<li>SBMs build on the Bayesian intuitions established earlier in this book; they employ a similar approach of using latent variables and prior distributions to model unknown/unobserved</li>
<li>TopSBM is really cool. Once you’re comfortable with the material in this chapter and the previous one, you should explore TopSBM on your own, or using the supplementary material online.</li>
</ul>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-karrer2011stochastic" class="csl-entry" role="listitem">
Karrer, Brian, and Mark Newman. 2011. <span>“Stochastic Blockmodels and Community Structure in Networks.”</span> <em>Physical Review E</em> 83 (1): 016107.
</div>
<div id="ref-peixoto2014hierarchical" class="csl-entry" role="listitem">
Peixoto, Tiago. 2014. <span>“Hierarchical Block Structures and High-Resolution Model Selection in Large Networks.”</span> <em>Physical Review X</em> 4 (1): 011047.
</div>
<div id="ref-peixoto2019bayesian" class="csl-entry" role="listitem">
Peixoto, Tiago P. 2019. <span>“Bayesian Stochastic Blockmodeling.”</span> <em>Advances in Network Clustering and Blockmodeling</em>, 289–332.
</div>
</div>
</section>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>For example, we could approximate the Negative Binomial distribution by using the Poisson distribution with a Gamma-distributed rate parameter. One way to do this would be to sample a rate parameter <span class="math inline">\(\lambda\)</span> from a Gamma distribution for each edge, use that parameter to sample the edge weight from the Poisson distribution, and then fit the SBM using the Poisson-distributed edge weights.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Well, unless you count the partition in the next model as a single partition, in which case this would probably be the second best guess!<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./23-causal-analysis.html" class="pagination-link" aria-label="Causal analysis">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Causal analysis</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./25-latent-topics-text-lda.html" class="pagination-link" aria-label="Latent topics in text (LDA)">
        <span class="nav-page-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Latent topics in text (LDA)</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/UWNETLAB/dcss_supplementary/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>